---
layout: post
title: 4-2.IR
category: Compiler
date: 2024-03-12 22:21:28 +0000
---

ìŠ¤í† ë¦¬ì§€ëŠ” ê°€ì¥ ëŠë¦¬ë©° ë¹ ë¥´ê²Œ êµ¬ë™ì‹œí‚¤ê¸° ìœ„í•´ì„œëŠ” ìì£¼ ì‚¬ìš©í•˜ëŠ” ë³€ìˆ˜ëŠ” ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•œë‹¤. ìì£¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë¶„ì„í•˜ëŠ” ê²ƒì„ localityë¥¼ ë³¸ë‹¤ê³  í•œë‹¤

cf. ìºì‹œë¥¼ ì–¸ê¸‰í•˜ì§€ ì•ŠëŠ” ê²ƒì€ ì§ì ‘ì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ì—†ê³  ì£¼ì†Œë¥¼ íŠ¹ì •í•  ìˆ˜ ì—†ìœ¼ë©° ë°ì´í„°ì˜ ì£¼ì†Œë“¤ì´ ë””ë¨ì— ìˆê¸° ë–„ë¬¸

# 2 Class of storage in processor

Variableì„ ì–´ë–»ê²Œ ì €ì¥í•˜ëŠ”ì§€ ì–´ë–¤ ê³³ì— ì–´ë–»ê²Œ ì €ì¥í•˜ëŠ”ì§€ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì

- ì»´í“¨í„° ì‹œìŠ¤í…œ í”„ë¡œì„¸ì„œì—ì„œëŠ” ë‘ê°€ì§€ ì†Œí† ë¦¬ì§€ê°€ ì¡´ì¬

**1) ë ˆì§€ìŠ¤í„°** : cpuì— ì¡´ì¬

- fast access, but only a few of them
- address spaceëŠ” programmerì—ê²Œ ë³´ì´ì§€ ì•ŠëŠ”ë‹¤
- pointer accessë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ
    
    ë ˆì§€ìŠ¤í„°ëŠ” ì‘ì€ ë©”ëª¨ë¦¬ì´ê³  cpuì˜†ì— ìˆê¸°ì— ë¹ ë¥´ê²Œ ì ‘ì†í•  ìˆ˜ ìˆì§€ë§Œ ìš©ëŸ‰ì´ ì‘ìŒ, ê·¸ë¦¬ê³  ë ˆì§€ìŠ¤í„°ì˜ addressëŠ” ì‚¬ì‹¤ í”„ë¡œê·¸ë˜ë¨¸ëŠ” ì•Œ ìˆ˜ ì—†ë‹¤. ê·¸ ì˜ë¯¸ëŠ” ë ˆì§€ìŠ¤í„°ëŠ” í¬ì¸í„°ë¡œ ì ‘ì†í•  ìˆ˜ ì—†ë‹¤
    

**2) memory** : dramì´ ê¸°ë³¸

- slow access, but large
- supports pointers
- storage class for each variableì€ HIRì—ì„œ LIRë¡œ ë§µí•‘ ì‹œ ëŒ€ë¶€ë¶„ ê²°ì •
    
    í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ëŠ” logical addressë¡œ ì ‘ì†ì´ ê°€ëŠ¥, í•˜ì§€ë§Œ ìŠ¤í† ë¦¬ì§€ ë³´ë‹¤ëŠ” ì‘ì§€ë§Œ ë ˆì§€ìŠ¤í„°ë³´ë‹¤ëŠ” ë©”ëª¨ë¦¬ëŠ” í¬ê³  ëŠë¦° ë””ë°”ì´ìŠ¤ì„. ì–´ë“œë ˆìŠ¤ë³„ë¡œ ì ‘ì†í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— í¬ì¸í„°ë¥¼ supportí•œë‹¤
    

ë°ì´í„°ë“¤ì´ ë””ë¨ì— ìˆë‹¤ê³  ìƒê°í•˜ê³  ë””ë¨ê³¼ ë ˆì§€ìŠ¤í„°ë¥¼ ì´ìš©í•´ì„œ varialeì„ assigní•˜ê²Œ ëœë‹¤

â†’ ë©”ëª¨ë¦¬ì™€ ë ˆì§€ìŠ¤í„°ì— ì ì ˆí•˜ê²Œ variableì„ ì•„ë‹ˆë©´ constructureë“¤ì„ ë°°ì¹˜í•  ê²ƒ

(ìì£¼ ì“°ê³  ì‘ì€ ë°ì´í„°ëŠ” ë ˆì§€ìŠ¤í„°ì— ìì£¼ ì“°ì§€ ì•ŠëŠ” ê±°ëŠ” ë©”ëª¨ë¦¬ì— ì €ì¥)

# Storage class slection

í”„ë¡œê·¸ë¨ì— ë‹¤ì–‘í•œ êµ¬ì¡°ì²´, ë³€ìˆ˜ë“¤ì€ ì–´ë–»ê²Œ ì €ì¥í•  ê²ƒì¸ê°€?

**1) standard (simple) approach**

- globals, statics - memory
- locals
    - composite type(structs, array...) - memory
    - scalars
        - access via & operator - memory
        - rest - virtual register
            - ê¸°ë³¸ì ìœ¼ë¡œ virtual registerì— ì €ì¥í•˜ê³  virtualì´ë¼ëŠ” ê²ƒì€ ë ˆì§€ìŠ¤í„°ì˜ ê°œìˆ˜ê°€ ë¬´í•œê°œë¼ê³  ìƒê°í•˜ëŠ” ê²ƒì„ ì˜ë¯¸
            - ëª¨ë“  ë³€ìˆ˜ë¥¼ ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•˜ë©´ í•˜ë“œì›¨ì–´ì— ìˆëŠ” ë ˆì§€ìŠ¤í„°ë³´ë‹¤ í›¨ì”¬ ë§ì€ ë ˆì§€ìŠ¤í„°ê°€ í•„ìš”í•˜ê²Œ ëœë‹¤. ë‚˜ì¤‘ì— ir ë ˆë²¨ì—ì„œëŠ” virtual registerë¡œ ìš°ë¦¬ê°€ ì›í•˜ëŠ” ë³€ìˆ˜ì˜ ê°œìˆ˜ë§Œí¼ ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•˜ê³  ë‚˜ì¤‘ì— ì‹¤ì œë¡œ íƒ€ê²Ÿ í•˜ë“œì›¨ì–´ì— ë§ëŠ” ì½”ë“œë¥¼ ë§Œë“¤ ë•Œ ìƒˆë¡œ ë ˆì§€ìŠ¤í„° ë§µí•‘ì„ í•œë‹¤. ì‚¬ìš©í•˜ëŠ” ë³€ìˆ˜ì˜ ìˆ˜ê°€ í•˜ë“œì›¨ì–´ ë ˆì§€ìŠ¤í„° ìˆ˜ë³´ë‹¤ í¬ë©´ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ” ê²½ìš°ê°€ ìˆëŠ”ë° ê·¸ ê²½ìš°ëŠ” **spilled to memory**ì´ë¼ê³  í•œë‹¤
                
                :  ì´ëŸ¬í•œ ê³¼ì •ì„ virtual to physical register mapping(code generationì—ì„œ register allocation)ì´ë¼ê³  í•œë‹¤. 
                
            
            cf. Virtual registerëŠ” abstract machineì—ì„œ ë ˆì§€ìŠ¤í„° ìˆ˜ê°€ ë¬´í•œê°œì„ì„ ê°€ì •í•˜ëŠ” ê²ƒì´ê³  Physical registerëŠ” ì‹¤ì œ íƒ€ê²Ÿ í•˜ë“œì›¨ì–´ì— ì¡´ì¬í•˜ëŠ” ë ˆì§€ìŠ¤í„°ë¥¼ ì˜ë¯¸í•¨
            
    
    local variableì€ ìì£¼ì“°ê³  ë°”ë¡œ ì½ì–´ì•¼í•˜ê¸° ë•Œë¬¸ì— ë©”ëª¨ë¦¬ì— ìˆìœ¼ë©´ ê°€ì ¸ì˜¤ëŠ”ë° ì‹œê°„ì´ ê±¸ë¦¬ë¯€ë¡œ ë ˆì§€ìŠ¤í„° íŒŒì¼ì— ìˆëŠ”ê²Œ ì¢‹ìŒ
    
- ìŠ¤íƒ ë‹¤ë“œ ì ‘ê·¼ì´ ê¸°ë³¸ì´ë©° ì‹¬í”Œí•˜ê¸°ì— ì´ê±¸ ê¸°ë³¸ìœ¼ë¡œ ìƒê°í•  ê²ƒ

**2) all memory approach**

- ëª¨ë“  variableë¥¼ ë©”ëª¨ë¦¬ì— ì§‘ì–´ë„£ê³  ëª‡ê°œë¥¼ ë ˆì§€ìŠ¤í„°ë¡œ ë§µí•‘

â†’ ì´ ê³¼ëª©ì—ì„œëŠ” ìŠ¤íƒ ë‹¤ë“œ ì ‘ê·¼ë°©ë²•ì„ ê¸°ë³¸ìœ¼ë¡œ í•  ê²ƒ

cf. register spill

r1=r2+r3
R4=r5+r6
R7=r8+r9â† ì§€ê¸ˆì˜ ì‹¤í–‰ì‹œì 
R10=r1+r4
R7=r7+1
Q. r10 ì‹¤í–‰í•˜ê¸° ì „ê¹Œì§€ ìš°ë¦¬ëŠ” r1,r4,r7ê°’ì´ ë ˆì§€ìŠ¤í„°ì— ìˆì–´ì•¼ í•œë‹¤. ì´ë•Œ ë§Œì•½ ë ˆì§€ìŠ¤í„°ê°€ ë‘ê°œë°–ì— ì—†ëŠ” í”„ë¡œì„¸ì„œì— ì´ ì½”ë“œë¥¼ ë§µí•‘í•˜ë ¤ë©´??
ë°”ë¡œ ì“°ì§€ ì•Šì„ ê°’ì„ ë©”ëª¨ë¦¬ì— ì €ì¥, ì—¬ê¸° ì‹œì ì—ì„œ store r4ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤. ì™œëƒë©´ r7ì„ ì €ì¥í•  locationì„ í™•ë³´í•´ì•¼ í•˜ë‹ˆê¹Œ! ê·¸ë‹¤ìŒì— store r7ì„ í•˜ê³  load r4ë¥¼ í•´ì•¼í•˜ë¯€ë¡œ ì†ë„ê°€ ì—„ì²­ ëŠë ¤ì§€ë¯€ë¡œ register allocationì´ ë§¤ìš° ì¤‘ìš” : **register spill**, ë ˆì§€ìŠ¤í„°ì˜ ê°’ì„ ë³´ì¡´í•  ìˆ˜ ì—†ì–´ì„œ ë©”ëª¨ë¦¬ì— ë³´ë‚´ëŠ” ê²½ìš°
ìŠ¤í•„ì´ ìˆë‹¤ë©´ load, storeì´ ìƒê²¨ì„œ ëŠë ¤ì§€ê²Œ ëœë‹¤.

â†’ ë ˆì§€ìŠ¤í„°ë¥¼ ë™ì‹œì— ë§ì´ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì¤„ì´ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”, ê°€ì¥ ì¤‘ìš”í•œ ì €ì¥ì†Œê°€ ë ˆì§€ìŠ¤í„°ì´ê¸° ë•Œë¬¸

# 4 Distinct Region of Memory

ë©”ëª¨ë¦¬ì— í”„ë¡œê·¸ë¨ì„ ë¡œë”©í•  ë•Œ, í”„ë¡œê·¸ë¨ì„ ì˜¬ë¦´ ë•Œ ì‚¬ìš©ë˜ëŠ” 4ê°€ì§€ ì˜ì—­

**1)code space**

- í”„ë¡œê·¸ë¨ instructionì„ ì €ì¥í•˜ëŠ” ê³µê°„, read only.

ì´ìœ ëŠ” í”„ë¡œê·¸ë¨ì„ ë””ë¨ì— ì˜¬ë¦¬ê³  í”„ë¡œê·¸ë¨ì„ êµ¬ë™ì‹œí‚¤ëŠ” ì¤‘ê°„ì— í¬ì¸í„°ê°€ ì˜ëª»ë˜ì–´ code spaceì— ìˆëŠ” ë°ì´í„°ë¥¼ ë³€ê²½í•˜ê²Œ ë˜ë©´ í”„ë¡œê·¸ë¨ì´ ì œëŒ€ë¡œ ëŒì§€ ì•Šì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì½”ë“œ ìŠ¤í˜ì´ìŠ¤ëŠ” read onlyë¡œ ë‘”ë‹¤. ê³ ì¹  ì‹œ report

**2) static region(or Global)**

- í”„ë¡œê·¸ë¨ì´ ë””ë¨ì— ë¡œë”©ëœ í›„ì— í”„ë¡œê·¸ë¨ì´ ëë‚  ë•Œê¹Œì§€ ê·¸ ê°’ì„ ê°€ì§€ê³  ìˆëŠ” variableì„ ì €ì¥í•œë‹¤
    
    Static, global variableì´ í•´ë‹¹
    

**3) stack**

- varaible that is only as long as the block within which they are defined
- ìŠ¤íƒì´ë¼ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì´ ìˆëŠ”ë° ì–˜ëŠ” í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ local variableì´ ì €ì¥ë¨.
    
    Local variable â€“ í•¨ìˆ˜ ì•ˆì—ì„œ ì„ ì–¸ë˜ê³  í•¨ìˆ˜ê°€ ëë‚˜ë©´ ì‚¬ë¼ì§€ëŠ” ë³€ìˆ˜ë¥¼ ì˜ë¯¸
    
- ìŠ¤íƒì€ ëŸ°íƒ€ì„ë§ˆë‹¤ function callì— ë”°ë¼ì„œ í¬ê¸°ê°€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ dynamicí•¨

**4)heap**

- malloc,newì™€ ê°™ì€ system storage allocatorë¥¼ í†µí•´ì„œ ì •ì˜ë˜ëŠ” ë³€ìˆ˜
- í”„ë¡œê·¸ë¨ì—ì„œ êµ¬ë™ ì‹œ ì–´ë– í•œ ë©”ëª¨ë¦¬ ì˜ì—­ì„ í™ì˜ì—­ìœ¼ë¡œ ë‘ê³  dynamic a locationìœ¼ë¡œ í• ë‹¹ë˜ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°–ê²Œ ë˜ëŠ” ë¶€ë¶„ì„ ì˜ë¯¸
- í• ë‹¹í•˜ê³  ì²«ë²ˆì§¸ ì£¼ì†Œë¥¼ ë¦¬í„´í•˜ê³  í¬ì¸í„° ë³€ìˆ˜ë¥¼ ì´ìš©í•´ì„œ ì ‘ì†í•¨. ë™ì í• ë‹¹ìœ¼ë¡œ í• ë‹¹ë˜ê³  ì‚¬ìš©ë˜ëŠ” ì˜¤ë¸Œì íŠ¸ë“¤ì„ í™ì˜ì—­ì—ì„œ ë§Œë“¤ì–´ì£¼ê²Œ ëœë‹¤. Mallocì´ë‚˜ new ë¥¼ ì´ìš©í•´ì„œ ìˆ˜í–‰

# âœï¸Memory Organization

![Untitled](/assets/2024-03-12-4-2-IR/Untitled.png)

ì‹¤ì œë¡œ í”„ë¡œê·¸ë¨ì´ ssdì—ì„œ dramìœ¼ë¡œ ë¡œë”©ë˜ë©´ ì´ëŸ° êµ¬ì¡°ë¡œ ë§Œë“¤ì–´ì§€ê²Œ ëœë‹¤. ì½”ë“œê°€ ì œì¼ ìœ„, static dataê°€ ìˆê³  ë‚˜ë¨¸ì§€ë¥¼ ìŠ¤íƒê³¼ í™ìœ¼ë¡œ, ìŠ¤íƒê³¼ í™ì€ ë°ì´í„°ë¥¼ ë” ë§ì´ í• ë‹¹í• ìˆ˜ë¡ ë°˜ëŒ€ë¡œ ì»¤ì§€ëŠ” í¸,ìŠ¤íƒì€ ìœ„ì—ì„œ ì•„ë˜ë¡œ í™ì€ ì•„ë˜ì—ì„œ ìœ„ë¡œ ì¦ê°€í•˜ëŠ” í¸

- ìŠ¤íƒì€ ë¡œì»¬ ë³€ìˆ˜ê°€ ì €ì¥ë˜ê³  functionì´ ìˆ˜í–‰ë  ë•Œë§ˆë‹¤ ì¦ê°€ë˜ê³  recursionì´ ë„ˆë¬´ ë§ìœ¼ë©´ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë°œìƒ : í™ì˜ì—­ì„ ë„˜ê²¨ì„œ ì‚¬ìš©ê°€ëŠ¥í•œ ì˜ì—­ì„ ë„˜ì–´ê°ˆ ë•Œ ë§í•¨
- ìŠ¤íƒì€ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ì €ì¥, í™ì€ ë™ì í• ë‹¹ìœ¼ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ë¥¼ ê´€ì¥í•˜ëŠ” ì˜ì—­
- ìŠ¤íƒê³¼ í™ì˜ ì‚¬ì´ì¦ˆëŠ” ëŸ°íƒ€ì„ë§ˆë‹¤ ë‹¬ë¼ì§€ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì“°ê¸° ìœ„í•´ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ì‚¬ìš©, ìŠ¤íƒê³¼ í™ ì¤‘ì—ì„œ ë¬´ì—‡ì„ ë” ë§ì´ ì‚¬ìš©í• ì§€ ëª¨ë¥´ê¸° ë•Œë¬¸, ì ˆëŒ€ì ì¸ ë°©í–¥ì€ ì¤‘ìš”í•˜ì§€ ì•Šê³  ë°˜ëŒ€ì¸ ê²ƒë§Œ ì•Œë©´ ë¨

cf. segmentation faultëŠ” í—ˆë½ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ ì ‘ê·¼ ì‹œ ë°œìƒ

# Variable Binding

Variableê³¼ memory locationì„ ë§¤ì¹­í•˜ëŠ” ê²ƒì„ ì˜ë¯¸

- Definitions
    - environment : nameê³¼ storage locationì„ ë§µí•‘í•˜ëŠ” í•¨ìˆ˜
    - state : storage loctaionì—ì„œ valueë¥¼ ë§µí•‘í•˜ëŠ” í•¨ìˆ˜
- storage location S with a name N == N is bound to S

ì–´ë– í•œ ì´ë…ì„ ê°€ì§„ variableì´ ì–´ë–¤ location sì— í• ë‹¹ì´ ë˜ì—ˆë‹¤ëŠ” ê²ƒì€ ì–´ë– í•œ nì´ sì— ë°”ìš´ë“œë˜ì—ˆë‹¤ë¼ê³  í‘œí˜„

## Static Allocation

- static storageëŠ” fixed allocationì´ê¸° ë•Œë¬¸ì— program executionë™ì•ˆ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤
- used for
    - global variables, constant, all static varibles in C
        
        ê¸€ë¡œë²Œ, ìƒìˆ˜, static variableì´ static allocationì„ ì´ìš©í•˜ê³  static regionì— ì €ì¥ë¨
        

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%201.png)

Static intë¼ê³  í•˜ë©´ í•œë²ˆë§Œ ì´ˆê¸°í™”ë˜ê³  ë‹¤ì‹œ ì´ˆê¸°í™”ë˜ì§€ ì•ŠëŠ”ë° ì–˜ê°€ static allocationìœ¼ë¡œ í• ë‹¹ë˜ì—ˆê¸° ë•Œë¬¸

## Heap allocation

- continuous storageë¥¼ ì¡°ê°ì¡°ê° ì§¤ë¼ì„œ ë©”ëª¨ë¦¬ ì˜¤ë¸Œì íŠ¸ë¥¼ ë§Œë“¤ì–´ ìŒ“ëŠ” ê²ƒ
    
    ì‚¬ì´ì¦ˆë¥¼ ì§€ì •í•´ì„œ allocateí•˜ë©´ ê³µê°„ì„ í• ë‹¹í•´ì„œ ì²«ë²ˆì§¸ í”¼ìŠ¤ë¥¼ ë¦¬í„´í•˜ê³  ê·¸ í¬ì¸í„°ë¡œ ì ‘ê·¼
    
- pieceë“¤ì€ ìˆœì„œ ìƒê´€ì—†ì´ deallocateë  ìˆ˜ ìˆë‹¤.
    
    ì›í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ë§Œë“¤ê²Œ ë˜ê³  í™ì— í• ë‹¹ëœ variableì€ í• ë‹¹ì´ í•´ì œë˜ëŠ” ê²ƒë„ ëœë¤í•˜ê²Œ ê°€ëŠ¥
    
- heap is global(í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ê¸° ë–„ë¬¸)
    - itemì€ ëª…ì‹œì ìœ¼ë¡œ freeë  ë•Œê¹Œì§€ ì¡´ì¬
        
        ì–´ëŠ ì •ë„ì˜ í¬ê¸°ê°€ ìˆê³  freeë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ì˜ì—­ì„ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì§€ì§€ ì•Šê²Œ ëœë‹¤.
        
    - garbage collectionì„ ì§€ì›í•œë‹¤ë©´ no one pointì¼ë–„ê¹Œì§€ ì¡´ì¬

ìŠ¤íƒì—ì„œ ì‚¬ìš©í•˜ëŠ” local variableì€ ì‹¤í–‰ë  ë•Œ ìƒê¸°ê³  í•´ì œë˜ë©´ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ì—ì„œ ì‚¬ë¼ì§€ê¸°ì— ë©”ëª¨ë¦­ ê´€ë¦¬ê°€ í•„ìš”ì—†ì§€ë§Œ ë™ì í• ë‹¹ìœ¼ë¡œ ëœ ê²½ìš°ì—ëŠ” ì§ì ‘ í•´ì œí•˜ì§€ ì•ŠëŠ” í•œ ì‚¬ë¼ì§€ì§€ ì•ŠëŠ”ë‹¤. ì˜¤ë¸Œì íŠ¸ì˜ delete, freeë¥¼ ì§ì— ë§ì¶°ì„œ ì˜í•´ì•¼í•œë‹¤. Freeí•˜ì§€ ì•Šì€ ë™ì•ˆ ì¡´ì¬í•˜ê³  garbage collectionì„ í•˜ê²Œ ë˜ë©´ ìê¸°ê°€ ì•Œì•„ì„œ ì—†ì• ëŠ” ê²½ìš°ë„ ìˆì§€ë§Œ ì‰¬ìš´ ì¼ì€ ì•„ë‹˜

# accessing static /heap variable

Static, heapìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ë³€ìˆ˜ë¥¼ ì–´ë–»ê²Œ ì ‘ê·¼?

- **static**
    - compilerê°€ ì•Œê³  ìˆëŠ” ì£¼ì†Œë¥¼ ì´ìš©(linkerê°€ í• ë‹¹)
    - compiler backendëŠ” symobolic name(label)ì„ ì‚¬ìš©
    
    Staticì€ ì»´íŒŒì¼ëŸ¬ê°€ ìœ„ì¹˜ë¥¼ ì•Œê³  ìˆìŒ. ì§€ì •ëœ ìœ„ì¹˜ì— ë§Œë“¤ê¸°ì— ê·¸ ë ˆì´ë¸”ì„ ì–´ë”˜ê°€ì— ì €ì¥í•˜ê³  ë§µí•‘ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ì ‘ì† ê°€ëŠ¥
    
- **heap**
    - unnamed locations
    - addressë¥¼ ê°€ì§€ê³  ìˆëŠ” dereferencing variableì„ í†µí•´ì„œ ì ‘ê·¼ ê°€ëŠ¥
    
    í™ì€ ì´ë¦„ì´ ì—†ê³  í¬ì¸í„°ë§Œ ì•Œê¸° ë–„ë¬¸ì— ì–´ë“œë ˆìŠ¤ë¡œ ë°ì´í„°ì— ì ‘ê·¼í•˜ê²Œ ëœë‹¤(pointer)
    

# ğŸ’¯Run-Time Stack(ë§¤ìš°ë§¤ìš° ì¤‘ìš”)

Functionì‹¤í–‰ ì‹œ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ë³€ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë¶€ë¶„

Run time stackì€ ìƒˆë¡œìš´ í•¨ìˆ˜ê°€ callë˜ê³  ë˜ ë¶€ë¥´ê³  ë¦¬í„´ë˜ê³  ë“±ë“±ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ callÂ  í• ë–„ë§ˆë‹¤ ì»¤ì§€ê³  returní•  ë•Œë§ˆë‹¤ ì‘ì•„ì§„ë‹¤. ìš©ëŸ‰ì´ ëŸ°íƒ€ì„ë§ˆë‹¤ ë‹¬ë¼ì§€ê¸°ì— ëŸ°íƒ€ì„ ìŠ¤íƒì´ë¼ê³  í•œë‹¤

- **ë§¤ function executionë§ˆë‹¤ frame(activation record)ìƒì„±**
    - functionì´ ë™ì‘í•˜ëŠ” execution environmentë¥¼ í‘œí˜„
        - definitonë§ˆë‹¤ í•˜ë‚˜ê°€ ì•„ë‹ˆë¼ í˜¸ì¶œë§ˆë‹¤ ìƒì„±ë¨! recursive functionì˜ ê²½ìš° í˜¸ì¶œë  ë•Œë§ˆë‹¤ frame ìƒì„±
        - ì½œë§ˆë‹¤ ìì‹ ì˜ í”„ë ˆì„ì„ ê°€ì§€ê²Œ ë˜ê³  recursionì´ ë°œìƒí•˜ë©´ ìê¾¸ ìë¼ë‚˜ì„œ ë‚˜ì¤‘ì— ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ê°€ ë‚˜ê²Œ ëœë‹¤.
    - local variables, parameters, return value, temporary storage(register spill, ë ˆì§€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•˜ë‹¤ê°€ ë‹¤ ì €ì¥í•  ìˆ˜ ì—†ì„ ë•Œ ë©”ëª¨ë¦¬ì— ì ì‹œ ì €ì¥í•˜ëŠ” ê²½ìš° ì‚¬ìš©) ì €ì¥
- **run-time stack of frames**
    - programì´ functionì„ í˜¸ì¶œí•  ë•Œ fì˜ frameì´ Push
    - fê°€ returnë  ë•Œ stack frameì´ pop
    - top frame = ì œì¼ ìœ„ì— ìˆëŠ” í”„ë ˆì„, í˜„ì¬ ì‹¤í–‰í•˜ê³  ìˆëŠ” functionì˜ frame

Q. runtime stackì€ í•˜ë‚˜ì˜ functionì„ ìˆ˜í–‰í•  ë•Œ ì»¤ì§ˆ ìˆ˜ ìˆì„ê¹Œ?

A. register spillë¡œ ì¸í•´ ì»¤ì§ˆ ìˆ˜ ìˆë‹¤.

## stack poiner

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%202.png)

- ê°€ì • : ìŠ¤íƒì€ ì•„ë˜ìª½ìœ¼ë¡œ ì»¤ì§€ë©° addressê°€ ì»¤ì§„ë‹¤ê³  ê°€ì •
- value of current frame accessed using 2 pointers
    - stack pointer(SP) : frame topì„ ê°€ë¦¬í‚´,Runtime stackì˜ top ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
    - frame pointer(FP) : frame baseë¥¼ ê°€ë¦¬í‚´, í˜„ì¬ ì‹¤í–‰í•˜ê³  ìˆëŠ” function frameì˜ based address
    - variable access : use offset from FP(SP)

ìŠ¤íƒ í”„ë ˆì„ì„ ê´€ë¦¬í•˜ê¸° ìœ„í•´ ë‘ê°œì˜ í¬ì¸í„°ë¥¼ ê°€ì§

Stack = first in last out, ì €ì¥í•˜ëŠ” ë©”ëª¨ë¦¬ì™€ push/popì´ë¼ëŠ” ì˜¤í¼ë ˆì´ì…˜, tos stack pointerê°€ í•„ìš”, ìŠ¤íƒì€ tosë¥¼ ì €ì¥í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë¯€ë¡œ í•­ìƒ í•˜ë‚˜ì”© ì¡´ì¬í•¨

- í”„ë ˆì„ì´ ë“¤ì–´ì˜¤ê²Œ ë˜ë©´ ê°€ì¥ ìœ„ì˜ ìœ„ì˜ ì£¼ì†Œê°€ stack pointerì´ê³  frame pointerëŠ” í˜„ì¬ ë‚´ê°€ ì‹¤í–‰í•˜ê³  ìˆëŠ” function frameì˜ ì²«ë²ˆì§¸ ìœ„ì¹˜ê°€ ëœë‹¤

Top frameì—ëŠ” ì—¬ëŸ¬ê°œì˜ local ë³€ìˆ˜ê°€ ìˆê³  accessë¥¼ í•˜ê¸° ìœ„í•´ì„œëŠ” fpë¥¼ ì´ìš©í•´ì„œ ì–¼ë§ˆë‚˜ ë¨¼ì§€ë¥¼ ê°€ì§€ê³  ì ‘ì†í•˜ê²Œ ëœë‹¤

Q. ì™œ fpë¥¼ ê°€ì§€ê³  ì™œ fpë¡œ ì ‘ê·¼í•˜ëŠ”ê°€???

A. ìŠ¤íƒ í¬ì¸í„°ë¥¼ í”„ë¡œê·¸ë¨ ë™ì‘ì´ ì»¤ì¡Œë‹¤ ì‘ì•„ì¡Œë‹¤ê°€ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸, ë³€í•˜ì§€ ì•Šì•„ë„ ë³€ìˆ˜ì™€ ë©€ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì ˆëŒ€ë¡œ ë³€í•˜ì§€ ì•ŠëŠ” fpë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°í•œë‹¤

### Why 2 stack pointers?

1. keep small offsets

Offsetì„ ì‘ê²Œ ë§Œë“¤ê³  ì‹¶ì–´ì„œ ì£¼ë¡œ fpì— ë³€ìˆ˜ì— ê°€ê¹ê¸° ë•Œë¬¸

literalì˜ ì‚¬ì´ì¦ˆê°€ ì œí•œë˜ì–´ìˆê¸° ë•Œë¬¸

1. real reason
- ìŠ¤íƒ ì‚¬ì´ì¦ˆê°€ í•­ìƒ ì»´íŒŒì¼íƒ€ì„ì— ì•„ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì»¤ì¡Œë‹¤ ì‘ì•„ì¡Œë‹¤ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ ê¸°ë³¸ based addressê°€ ë³€í•˜ë©´ ì œëŒ€ë¡œ ë™ì‘í•˜ì§€ ì•Šì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— fpë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì ‘ì†
- register spillì´ë‚˜ allocê°€ ì¶”ê°–ê±°ìœ¼ë¡œ í•„ìš”í•  ìˆ˜ ìˆê¸° ë•Œë¬¸

## Anatomy of a Stack frame

stack frameì— ë“¤ì–´ê°€ëŠ” ë°ì´í„°

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%203.png)

í˜„ì¬ tos frameì„ ë³´ë©´ fpë¶€í„° ì‹œì‘í•˜ëŠ”ë° ì´ì „ì˜ fpê³¼ local ë³€ìˆ˜ì™€ temporaryê°€ ì €ì¥ë˜ê³  íŒŒë¼ë¯¸í„°ê°€ ì €ì¥ë˜ëŠ”ë° íŒŒë¼ë¯¸í„°ëŠ” ë‚˜ì˜ íŒŒë¼ë¯¸í„°ê°€ ì•„ë‹ˆë¼ ë‚´ê°€ ë¶€ë¥´ëŠ” í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ì´ê³  return addressë„ ë‚´ê°€ ìƒˆë¡œ ë¶€ë¥´ëŠ” í•¨ìˆ˜ì˜ return addressì„

í˜„ì¬ ì‚¬ìš©ë˜ê³  ìˆëŠ” ë°ì´í„°ëŠ” ê·¸ ì „ í”„ë ˆì„ì˜ íŒŒë¼ë¯¸í„°ì™€ return address + ë…¸ë€ìƒ‰ tempê¹Œì§€

function callí•˜ê¸° ì „ì— íŒŒë¼ë¯¸í„°ì™€ Return addressë¥¼ ì €ì¥í•œ í›„ ì§€ê¸ˆ ìˆ˜í–‰í•˜ê³  ìˆëŠ” í•¨ìˆ˜ê°€ ì¡´ì¬í•œë‹¤ë©´ ì´ì „ì˜ fpê°’ì„ ì €ì¥í•˜ê³  local, temp ë“±ì„ ì €ì¥í•˜ê³  ë‹¤ìŒ í˜¸ì¶œí•  functionì´ ì‚¬ìš©í•  ê°’ë“¤ì„ ì €ì¥í•´ì¤€ë‹¤.

cf. ì•„í‚¤í…ì²˜ë§ˆë‹¤ fp,spì˜ ì§€ì ì„ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ.

### â€¼ï¸Stack Frame Construction Example(ë§¤ìš°ë§¤ìš°ë§¤ìš°ë§¤ìš° ì¤‘ìš”)

ì˜ˆì‹œ ì¤‘ìš”, ìŠ¤íƒì´ ì–´ë–»ê²Œ ì»¤ì§€ëŠ”ì§€ ì•Œì•„ì•¼ í•¨

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%204.png)

ë©”ì¸í•¨ìˆ˜ê°€ ìˆê³  local ë³€ìˆ˜ a,bê°€ ìˆê³  function callí•˜ê²Œ ë˜ë©´ a+bê°€ íŒŒë¼ë¯¸í„°ë¡œ ê°€ê²Œ ëœë‹¤. ê·¸ ë’¤ì— mainì˜ fpê°€ ì €ì¥ë˜ê³  mainì˜ return address í›„ì— b,c,ê°€ ì €ì¥ë¨

ë‚˜ë¥¼ ë¶€ë¥¸ functionì˜ fpë¥¼ ì €ì¥í•˜ëŠ” ì´ìœ ëŠ” returnì´ ë  ë•Œ ë‘ê°œì˜ í¬ì¸í„°(sp,bp)ë¥¼ ì´ì „ì˜ ìƒíƒœë¡œ ë˜ëŒë¦¬ê¸° ìœ„í•¨

Class problem-ì¤‘ìš”

- ìŠ¤íƒì— ë“¤ì–´ê°€ëŠ” í”„ë ˆì„ì´ ì–´ë–»ê²Œ ì‚¬ë¼ì§€ê³  ìƒê¸°ëŠ”ì§€ ë³´ë©´ ì¢‹ì„ ë“¯

# Saving Register

ìŠ¤íƒì— ë ˆì§€ìŠ¤í„° ì •ë³´ë¥¼ ì €ì¥í•´ì¤˜ì•¼ í•œë‹¤

- problem : execution of invoked function may overwrite useful values in register
    
    í•˜ë“œì›¨ì–´ì ì¸ ì´ìŠˆê°€ ì¡´ì¬, cpuëŠ” ê° í•¨ìˆ˜ë§ˆë‹¤ ë ˆì§€ìŠ¤í„°ë¥¼ ì´ìš©í•´ì„œ ë™ì‘í•˜ê²Œ ë¨. í•˜ë‚˜ì˜ í•¨ìˆ˜ê°€ ì‹¤í–‰ë Â  ë•Œ ë‹¤ìŒ í•¨ìˆ˜ì—ì„œ ì´ì „ì— ì‚¬ìš©ë˜ê³  ìˆë˜ ë ˆì§€ìŠ¤í„°ë¥¼ ë‹¤ì‹œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš° ì¡´ì¬
    
    : ì´ì „ì— ë™ì‘í•˜ë˜ í•¨ìˆ˜ê°€ ëë‚˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ë°±ì—…ì„ í•´ì¤˜ì•¼ í•œë‹¤, Temporary dataë¥¼ ì €ì¥í•´ì¤˜ì•¼ í•œë‹¤
    

**â†’ generated code must :** 

- save registers when function is invoked
- restore registers when funciton returns
- ê°€ëŠ¥í•œ ë°©ë²•(Callee(callì„ ë‹¹í•˜ëŠ”í•¨ìˆ˜), caller(callí•˜ëŠ” í•¨ìˆ˜))
    - callee saves(addê°€ ì €ì¥)/ restores registers(addê°€ ë¦¬í„´ë˜ê¸° ì „ì— ë³µêµ¬)
    - caller saves(callí•˜ê¸° ì „ì— main ì €ì¥) / restores registers(ëŒì•„ì™€ì„œ main ë³µêµ¬)
    
    â†’ ì´ëŸ¬í•œ ë ˆì§€ìŠ¤í„° ì„¸ì´ë¸Œí•˜ê³  ë³µì›í•˜ëŠ” ê²ƒì„ ë‘˜ë‹¤ í•  ìˆ˜ ìˆê³  ì´ê±´ ì»´íŒŒì¼ëŸ¬ê°€ ê²°ì •
    

ex) 

main(){

int a,b,c;

add();

c=a+1;

ë©”ì¸ì´ ìˆê³  addÂ Â  í•¨ìˆ˜ë¥¼ ë™ì‘ì‹œí‚¬ ë•Œ ì´ì „ì—ë„ r5ë¥¼ ì‚¬ìš©í•˜ê³  add í›„ì—ë„ r5ë¥¼ ì‚¬ìš©í•˜ë©°Â addí•¨ìˆ˜ì—ì„œë„ ì‚¬ìš©ëœë‹¤ë©´ ìŠ¤íƒì— r5ê°’ì„ ì €ì¥í•´ë†”ì•¼ í•œë‹¤ ê·¸ë‹¤ìŒì— addì—ì„œëŠ” ì‚¬ìš©í•œ í›„ ëë‚  ë•Œ r5ë¥¼ ë‹¤ì‹œ ë³µì›í•œë‹¤ë©´ addë¥¼ ë¦¬í„´í•˜ê³  ë‚˜ì„œë„ ììœ ë¡­ê²Œ ì‚¬ìš© ê°€ëŠ¥

- callerëŠ” Â  main, Â calleeëŠ”  add

}

int add(){

}

- ìƒˆë¡œ ì½œëœ í•¨ìˆ˜ ì‹¤í–‰ì‹œê°„ë™ì•ˆ ì›ë˜ìˆë˜ ë ˆì§€ìŠ¤í„° ì¤‘ì— ë‚˜ì¤‘ì— ì‚¬ìš©í•˜ëŠ” ë³€ìˆ˜ë¥¼ overwrite í• ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì½œí•˜ê¸° ì „ì— ìŠ¤íƒì— ë¯¸ë¦¬ ì €ì¥í•´ë†“ëŠ”ë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì½œ ë  ë•Œ ë ˆì§€ìŠ¤í„°ê°’ë“¤ì„ ì €ì¥í•˜ê³  ë‹¤ì‹œ ë³µêµ¬í•˜ëŠ” ì½”ë“œê°€ ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤. ë˜í•œ ì¶”ê°€ë˜ëŠ” ìœ„ì¹˜ë„ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
- ì½œí•  ë•Œë§ˆë‹¤ ëª¨ë“  ë ˆì§€ìŠ¤í„°ë¥¼ ì €ì¥ -> ë„ˆë¬´ ì†ë„ê°€ ëŠë¦¬ë‹ˆê¹Œ í•„ìš”í•œ ë ˆì§€ìŠ¤í„°ë“¤ë§Œ ì €ì¥ -> ë©”ì¸ í•¨ìˆ˜ì— ë ˆì§€ìŠ¤í„°ë¥¼ ë§ì´ ì‚¬ìš©í•˜ì§€ ì•Šê³  addë„ ë§ì´ ì‚¬ìš©í•˜ì§€ ì•Šë‹¤ë©´ ì €ì¥í•˜ì§€ ì•Šì„ ê²½ìš°ë„ ìˆìŒ
Function call return ì‹œ ë ˆì§€ìŠ¤í„°ë¥¼ ì €ì¥í•˜ëŠ” ì˜¤ë²„í—¤ë“œê°€ í¬ë‹ˆê¹Œ add functionì´ ì‘ë‹¤ë©´ function callë³´ë‹¤ëŠ” inline í‚¤ì›Œë“œë¥¼ ë¶™ì—¬ì„œ ì¤„ì—¬ì¤„ ìˆ˜ ìˆìŒ. ëŒ€ì‹  ì¸ë¼ì¸ì„ ì“°ë©´ function call return overheadëŠ” ì¤„ì—¬ì£¼ë‹ˆë§Œ code sizeê°€ ì»¤ì§€ë©° register pressureê°€ ì»¤ì ¸ì„œ ì¢‹ì§€ ì•ŠìŒ. í° í•¨ìˆ˜ë¼ë©´ ë©”ì¸ í•¨ìˆ˜ê°€ í‚µí•´ì•¼í•˜ëŠ” ë ˆì§€ìŠ¤í„°ì˜ ê°œìˆ˜ì™€ addí•¨ìˆ˜ê°€ í‚µí•´ì•¼í•˜ëŠ” ë ˆì§€ìŠ¤í„° ìˆ˜ë¥¼ í•©í•´ì„œ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŒ
â†’ Inlineì€ í•¨ìˆ˜ ì‚¬ì´ì¦ˆê°€ ì‘ì„ ë•Œ ìœ ìš©
ì‹¤ì œë¡œ function callì„ í•˜ë©´ register managementí•´ì•¼í•˜ëŠ”ë° ì´ëŸ¬í•œ ì½”ë“œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë§Œë“¤ì–´ì¤˜ì•¼ í•œë‹¤.

Q. callí•˜ê¸° ì „ì— ë ˆì§€ìŠ¤í„°ë¥¼ ì €ì¥í•˜ëŠ” ì´ìœ ?

A. ë ˆì§€ìŠ¤í„°ë¥¼ calleeì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë–„ë¬¸, ë ˆì§€ìŠ¤í„°ê°€ ê³µìœ ë˜ê³  ìˆê¸° ë•Œë¬¸ì— ë©”ì¸ í•¨ìˆ˜ì—ì„œ ëŒì•„ì™”ì„ ë•Œ ì˜ë¯¸ìˆëŠ” ê°’ë“¤ë§Œ ì €ì¥í•˜ë©´ ë¨

Q. ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆì„ê¹Œ?

A. data flow anlysisë¥¼ í†µí•´ì„œ ê° Local variableì˜ life ragneë¥¼ ë¶„ì„í•´ì„œ ì €ì¥ìœ ë¬´ë¥¼ ê²°ì • ê°€ëŠ¥

Q. ë¬´ì¡°ê±´ ì €ì¥í•´ì•¼ í• ê¹Œ?

A. Aì—ì„œ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš°ë¼ë©´ ë©”ëª¨ë¦¬ì— ì €ì¥ë˜ì§€ ì•Šì•„ë„ ëœë‹¤.  ì»´íŒŒì¼ëŸ¬ê°€ ê²°ì •

# Calling Sequences(ê¼­ ë”°ë¼í•´ë³¼ ê²ƒ)

(calling convention)

ì‹¤ì œë¡œ function callì´ ì¼ì–´ë‚  ë•Œ ì–´ë–»ê²Œ í”„ë ˆì„ì„ ë§Œë“œëŠ” ì½”ë“œë¥¼ ë§Œë“¤ì–´ ë‚¼ ê²ƒì¸ê°€?

- generate code which pushes value on stack:
    - before call(caller responsibilities)
    - at function entry(callee responsiblities)
- genearte code which pop values off stack:
    - after call instructions(caller responsibilities)
    - at return instructions(callee responsiblities)

## Push values on stack

- **code before call instruction**
    - push each actual parameter
    - push caller-saved registers(temporary register value)
    - push static link
    - push return address(current pc) and jump to callee
- **prologue = code at function entry**
    - push dynamic link(old fp)
    - old stack pointerê°’ì´ new frame pointerê°€ ë¨
    - push callee saved register
    - push local variable

## Pop values from stack

- **Epilogue = code at return instruction**
    - pop callee saved register(restore)
    - store return value at appropriate place
    - restore old stack pointer==pop callee frame
    - pop old frame pointer
    - pop return address and jump to that address
- **code after call**
    - pop(restore) caller-saved registers
    - use return value

### Example Call(ì˜ˆì‹œ ê¼­ ë”°ë¼ê°€ë³¼ ê²ƒ, ëª‡ë°”ì´íŠ¸ì¸ì§€ë„ ì•Œì•„ë†“ì„ ê²ƒ)

- call foo(3,5),machineì€ r1,r2 ë ˆì§€ìŠ¤í„°ë¥¼ ê°€ì§€ê³  ìˆê³  callee save
- code before call instruction
    - push arg1 : [sp]= 3
    - push arg2 : [sp+4] = 5
    - make room for return address and 2 args : sp = sp +12
    - call foo
- prologue
    - push old frame pointer : [sp] = fp
    - compute new fp : fp = sp
    - push callee saved register : [sp+4] = r1, [sp+8] = r2
    - create frame with 3 local variabble, sp = sp + 24

â†’ ì´ 36ë°”ì´íŠ¸ ì¦ê°€ 

- epilogue
    - pop r1,r2 : r1=[sp - 20], r2 = [sp-16]
    - restore old fp : fp = [sp-24]
    - pop frame : sp = sp - 24
    - pop return address and excture return
- code after call
    - use return value
    - pop args : sp = sp - 12
    
    â†’ 36ë°”ì´íŠ¸ê°€ ê°ì†Œí•˜ë¯€ë¡œ ë‹¤ì‹œ ì›ë˜ëŒ€ë¡œ ëŒì•„ì™”ìŒ
    

### Accessing stack variables

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%205.png)

- stack variableì€ fpë¡œë¶€í„°ì˜ offsetì„ ì´ìš©í•˜ì—¬ ì ‘ê·¼
- íŒŒë¼ë¯¸í„°ëŠ” - offsetìœ¼ë¡œ ì ‘ê·¼í•˜ê³  ë¡œì»¬ë³€ìˆ˜ëŠ” +offsetìœ¼ë¡œ ì ‘ê·¼

# Data layout

Compositeí•œ dataë¥¼ ì–´ë–»ê²Œ ì €ì¥í•˜ëŠ”ê°€? ì—¬ê¸°ìˆëŠ” ê²ƒë§Œ ì´í•´í•˜ë©´ ë¨, ë°ì´í„° ë ˆì´ì•„ì›ƒì„ ì–´ë–»ê²Œ í•  ê²ƒì¸ê°€?

- naive layout strategies generally employed
    - place the data in the order the programmer declared it!
- ë‘ê°€ì§€ issue : size, alignment
    
    1 : ê°ê°ì˜ ë°ì´í„°íƒ€ì…ì˜ ì‚¬ì´ì¦ˆ
    
    2 : alignment, ìœ„ì¹˜ë“¤ì´ ì˜ ë§ì•„ì•¼ í•œë‹¤.
    

### size - how many bytes is the data item?

- base types have some fixed size : ê°ê°ì˜ ì•„ì´í…œì´ ëª‡ ë°”ì´íŠ¸ë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€
    - char(1),int(4),float(4),double(8)
- **composite types(structs, unions arrays)**
    - overall size = sum of the components(componentí•©ë³´ë‹¤ í´ ìˆ˜ ìˆìŒ. Alignmentë¥¼ ìœ„í•´ì„œ)
    - calculate an offset for each field : ê°ê°ì˜ ì²«ë²ˆì§¸ addressë¥¼ offsetì´ë¼ê³  í•˜ê³  typeì˜ ë§¨ ì²˜ìŒ ì£¼ì†Œë¥¼ base addressë¼ê³  í•´ì„œ composite typeì€ structureì˜ base address + offsetìœ¼ë¡œ ì ‘ê·¼
- ì‚¬ì´ì¦ˆì— ë”°ë¼ì„œ alignmentê°€ ì •í•´ì§ ë§Œì•½ì— characterë¼ë©´ 0123..ì´ addressë¡œ ì €ì¥ë  ìˆ˜ ìˆê³  intë¼ë©´ 4ë°”ì´íŠ¸ë‹ˆê¹Œ 0,4,8.. ë“±ì— ì €ì¥ë  ìˆ˜ ìˆìŒ

ex) struct{char a; int b; double c; char d; }

ê¸°ë³¸ì ìœ¼ë¡œ ìˆœì°¨ì ìœ¼ë¡œ ì €ì¥í•œë‹¤ë©´ character variable, aê°€ ë“¤ì–´ê°„ë‹¤ë©´ 0ë²ˆì§€ê°€ aë¼ë©´ integer bê°€ 1,2,3,4 ë“¤ì–´ê°ˆ ìˆ˜ëŠ” ìˆì§€ë§Œ alignmentê°€ ë˜ì–´ì•¼ í•˜ë¯€ë¡œ bëŠ” 0,4,8ì—ë§Œ ê°€ëŠ¥, aì—ì„œ ì§€ì •í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ë¹„ì›Œì•¼ í•¨.

Q. ë§Œì•½ ìºë¦­í„°ê°€ í•˜ë‚˜ ìˆì–´ì„œ ë¹ˆ ìë¦¬ì— ë“¤ì–´ê°€ë©´ ì¢‹ì„ ê±° ê°™ì€ë°?? 

A. Structureì„ íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ ìˆœì„œë¥¼ ë°”ê¿”ì„œ ì €ì¥í•  ìˆ˜ëŠ” ìˆì§€ë§Œ ìˆœì°¨ì ìœ¼ë¡œ í•˜ëŠ” ê²ƒì´ ê¸°ë³¸ì´ë¼ì„œ ë’¤ì— ë“¤ì–´ê°ˆ ê²ƒ, ì‹œí—˜ë¬¸ì œì—ë„ alignmentì— ë§ì¶°ì„œ ìŒ“ê³  ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ì˜ ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šì„í…Œë‹ˆ ì½”ë“œì˜ ìˆœì„œë¥¼ ë°”ê¾¸ë˜ê°€ ì»´íŒŒì¼ëŸ¬ê°€ ë°”ê¾¼ë‹¤ê³  ê°€ì •í•´ì„œ íš¨ìœ¨ì ìœ¼ë¡œ Structure ì‚¬ì´ì¦ˆë¥¼ ì¤„ì´ë„ë¡ í•´ë´ë¼ ë¬¼ì–´ë³¼ ìˆ˜ ìˆìŒ

# Memory Alignment

- cannot arbitarily pack variables into memory

â†’ alignmentë¥¼ ê³ ë ¤í•´ì•¼ í•œë‹¤

- golden ruleâ€” address of variable is aligned based on the size of the variable, variable ì‚¬ì´ì¦ˆì— ë§ì¶°ì„œ alignë˜ì–´ì•¼ í•œë‹¤
    - ìºë¦­í„°ëŠ” 0,1,2,3,... ì´ê³  shortëŠ” 0,2,4,6,8 ì´ê³  intëŠ” 0,4,8 ..
    - ì»´íŒŒì¼ëŸ¬ë§ˆë‹¤ ë‹¤ë¥´ë¯€ë¡œ ì‹œí—˜ì—ì„œëŠ” ì—¬ê¸°ì„œ ì–˜ê¸°í•œëŒ€ë¡œ ë³€ìˆ˜ ìˆœì„œì— ë§ì¶°ì„œ í•˜ê±°ë‚˜ ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ë¦¬ì˜ ì‚¬ì´ì¦ˆë¥¼ ì¤„ì´ê¸° ìœ„í•´ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤ ê°€ì •í•´ì„œ ì“°ë©´ ë¨

# structure alignment(for c)

- Declareëœ ìˆœì„œë¡œ layoutí•˜ëŠ”ë° ì´ë•Œ golden rule(ìê¸° ì‚¬ì´ì¦ˆë”°ë¼ì„œ address ì§€ì •)ì„ ì‰í•´ì„œ ì§€ì •
- **identify largest field,** ê°€ì¥ í° í•„ë“œê°€ ë¨¼ì§€ ì•Œì•„ì•¼ í•œë‹¤
    - ê°ê°ì˜ structureì€ ê°€ì¥ í° í•„ë“œì˜ alignmentê°€ ë§ê²Œ ì§€ì •ë˜ì–´ì•¼ í•œë‹¤.
    - size of overall structëŠ” Largest fieldì˜ ë°°ìˆ˜ì´ë‹¤

![Untitled](/assets/2024-03-12-4-2-IR/Untitled%206.png)

Bê°€ largest fieldë¥¼ ì •ì˜í•œë‹¤ë©´ 12ê°€ ë¨. ì™œëƒë©´ ê°€ì¥ í° í•„ë“œì˜ integer bì˜ offsetê³¼ ê°™ì´ ê°€ê¸° ë•Œë¬¸ì— ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ë“¤ì´ ì¡´ì¬

D[1]ì€ 12ë¶€í„° ì‹œì‘í•œë‹¤ëŠ” ì˜ë¯¸, d[1]ì˜ charì´ 9,10ì— ë“¤ì–´ê°ˆ ìˆ˜ ì—†ë‹¤ëŠ” ì˜ë¯¸!

ê°€ì¥ í° í•„ë“œì˜ bì˜ offsetê°’ê³¼ ê°™ì´ ê°€ì•¼í•˜ê¸° ë•Œë¬¸ì— ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê°’ì´ ì¡´ì¬í•  ê²ƒ

ì‹œí—˜ë¬¸ì œë„ ì´ëŸ°ê±¸ ë‚¸ë‹¤ê³  í•œë‹¤ë©´ ì˜¤ëŠ˜ ì–˜ê¸°í•œ ê±°ì •ë„ë¡œë§Œ ë‚˜ì˜¬ ê²ƒ

- golden ruleì´ ìˆê³  (alignment ë§ì¶°ì•¼ í•œë‹¤), declareëœ ìˆœì„œë¡œ ë ˆì´ì•„ì›ƒí•˜ê³  ê°€ì¥ í° fieldì— alignì´ ë§ë„ë¡ ì²«ë²ˆì§¸ addressì— ë§ì•„ì•¼ í•œë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì„ ì–¸ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤ë©´ ë” ì¤„ì¼ ìˆ˜ ìˆë‹¤

Cf. bê°€ ì œì¼ ë¨¼ì € ì™€ë„ ìƒê´€ì€ ì—†ìŒ

Cf. alignmentê°€ ë“¤ì–´ì˜¨ ê²ƒì€ ì‚¬ì´ì¦ˆë¼ë¦¬ ë¶™ê²Œ ë˜ë©´ í•˜ë“œì›¨ì–´ì ì¸ ë¬¸ì œê°€ ì¡´ì¬, 32ë¹„íŠ¸ë¼ë©´ 32ë¹„íŠ¸ ë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ì ‘ì†í•˜ê²Œ ë˜ëŠ”ë° alignì´ ì˜ëª»ëœë‹¤ë©´ ë‘ë²ˆì˜ loadê°€ í•„ìš”í•˜ê¸° ë•Œë¬¸

Largest filedê°€ 4ë°”ì´íŠ¸ì´ê³  ê·¸ëŒ€ë¡œ ë§ì¶°ì•¼ í•œë‹¤

Intê°€ ì•„ë‹ˆë¼ doubleì´ë¼ë©´ d[1]ì€ 16ë¶€í„° ì‹œì‘í•˜ëŠ” ê²ƒ
