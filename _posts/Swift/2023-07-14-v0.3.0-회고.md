---
layout: post
title: v0.3.0 개발하면서 알게 된 점
date: 2023-07-14 19:20:23 +0900
category: Swift
---
# v0.3.0 개발하면서 알게 된 점

### Post API가 완벽한 것 같은데 안된다면?

- 제발 encodoing을 지정해줄 것…

```cpp
let jsonEncoder = JSONEncoder()
let jsonData = try jsonEncoder.encode(parameterList)
let jsonList = try JSONDecoder().decode([[String: String]].self, from: jsonData)
            
let parameter = ["uuid": uuid,
                "share_list": jsonList] as [String: Any]
            
logPrint(logType: .debug, message: "Url: \(url), parameter: \(parameter)")
            
return Observable.create { observer -> Disposable in
      RxAlamofire.requestDecodable(.post, url, parameters: parameter, encoding: JSONEncoding.default).subscribe(onNext: { (_, response: Response<Bool>) in
...
```

### api를 여러번 많이 부르는 경우?

- Rx보다는 async가 훨씬 처리하기 쉬움

```cpp
func getApiExample(email: String) -> Observable<Bool?> {
        logPrint(logType: .info, message: "Start")
        
        let url = BASE_URL+"/getApiExample?email_address=\(email)"
        
        logPrint(logType: .debug, message: "url: \(url)")
        
        return Observable.create { observer -> Disposable in
            RxAlamofire.requestDecodable(.get, url).subscribe(onNext: { (_, response: Response<String>) in
                logPrint(logType: .debug, message: "Response: \(response)")
                let resultBool = response.status == 200 ? true : false
                observer.onNext(resultBool)
            }, onError: { error in
                logPrint(logType: .error, message: error.localizedDescription)
                observer.onNext(nil)
            }).disposed(by: self.disposeBag)
            logPrint(logType: .info, message: "End")
            return Disposables.create()
        }
    }
```

```cpp
func postApiExample(uuid: String) async -> Bool {
        logPrint(logType: .info, message: "Start")
        let url = BASE_URL+"/postApiExample"
        let parameters =  [
            "uuid": uuid
        ] as [String: Any]
        
        logPrint(logType: .debug, message: "url: \(url), paramter: \(parameters)")
        
        let request = AF.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default)
        let result = await request.serializingDecodable(Response<Bool>.self).result
        
        switch result {
        case .success(let data):
            logPrint(logType: .debug, message: data)
            logPrint(logType: .info, message: "End")
            return data.data ?? false
        case .failure(let error):
            logPrint(logType: .error, message: error.localizedDescription)
            logPrint(logType: .info, message: "End")
            return false
        }
   }
```

<aside>
✅ 단, async를 쓰는 쪽에서 아래와 같은 추가적인 코드 필요

</aside>

```cpp
Task {
            await postApiExample(uuid: "")
}
```

<aside>
✅ fcm token은 영구적일 것 같지만 자주 바뀐다…  다만 언제 바뀌는지는 잘 모르겠음..

</aside>

### Post로 file을 보내야한다면?

- header를 "Content-type": "multipart/form-data"로 지정해줘야 함
- AF.upload()함수를 이용
  
```cpp
func registerFile(uuid: String, mapperURL: URL? = nil) async -> Bool? {
        logPrint(logType: .info, message: "Start")
        let url = BASE_URL+"/registerFile"
        
        
        let headers: HTTPHeaders = [
            "Content-type": "multipart/form-data"
        ]
        let parameters: [String: Any]
        
        parameters =  [
                "uuid": uuid]  as [String: Any]
        
        logPrint(logType: .debug, message: "Url: \(url), Paramter: \(parameters)")
        
        let request = AF.upload(multipartFormData: {multiPart in
            for (key, value) in parameters {
                print(key)
                if let temp = value as? String {
                  multiPart.append(temp.data(using: .utf8)!, withName: key)
                } else if let temp = value as? Int {
                  multiPart.append("\(temp)".data(using: .utf8)!, withName: key)
                } else {
                    logPrint(logType: .error, message: "parameter Is not string or int")
                }
            }
            if let url = mapperURL,
                    let data = try? Data(contentsOf: url) {
                    multiPart.append(data, withName: "mapper", fileName: url.lastPathComponent, mimeType: "dat")
                }
        }, to: url, method: .post, headers: headers).uploadProgress(queue: .main, closure: { progress in
            logPrint(logType: .debug, message: "Upload Progress: \(progress.fractionCompleted)")
        })
        let result = await request.serializingDecodable(Response<Bool>.self).result
        
        switch result {
        case .success(let data):
            logPrint(logType: .debug, message: data)
            logPrint(logType: .info, message: "End")
            return data.data
        case .failure(let error):
            logPrint(logType: .error, message: error.localizedDescription)
            logPrint(logType: .info, message: "End")
            return false
        }
        
    }
```
