---
layout: post
title: v0.5.0-회고
date: 2021-01-29 19:20:23 +0900
category: Swift
---
# 0.5.0 개발 회고

### DynamicMemberLookUp

state.model.count를 바로 state.count로 갈 수 있도록 하는 것!!

```swift
@dynamicMemberLookup
struct Child {
	let name: String
	let parent: Parent
	subscript<T>(dynamicMember keyPath: KeyPath<Parent, T>) -> T {
    parent[keyPath: keyPath]
	}
}
```

- CoreData에서 codegen을 했는데 이상하게 자꾸 redefinition에러가 난다???
    - 디비마다 NOne으로 설정 다 했는지 체크할 것!

### SecretSharing Entity

![Uniwaffle_v0.5.0_SecretSharingEntityDiagram.drawio.png](0%205%200%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%92%E1%85%AC%E1%84%80%E1%85%A9%203d0e4d8c445845b9bcf7dae6f05f13aa/Uniwaffle_v0.5.0_SecretSharingEntityDiagram.drawio.png)

![최종버전: 다합치는게 더 낫겠다고 결정!~](0%205%200%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%92%E1%85%AC%E1%84%80%E1%85%A9%203d0e4d8c445845b9bcf7dae6f05f13aa/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.33.29.png)

최종버전: 다합치는게 더 낫겠다고 결정!~

- **usecase에 외부 라이브러리가 들어가면 안되고 data module에 있어야한다!!**
    - 도메인은 서버나 라이브러리 상태에 상관없이 유지되어야 하기 때문!!

association은 대등한 관계에서 사용하는 개념!

- composition: 포함관계, 생명주기 유사
    - ex) native가 사라지면 token도 사라지니까 composition인거지!
- aggregation: 조금 약한 결합관계, 부모가 삭제되어도 관계없음

### 디자인 시스템 적용기

- 폰트
    - [https://eunjin3786.tistory.com/569](https://eunjin3786.tistory.com/569) 이걸 보고 infoplist를 직접 넣어줘야 함
- color
    - [https://tigi44.github.io/ios/iOS,-Swift-Add-Resources-to-a-Swift-Package(Bundling-Resources)/](https://tigi44.github.io/ios/iOS,-Swift-Add-Resources-to-a-Swift-Package(Bundling-Resources)/)로 넣어줘야 함
- UI그리다가 이상하게 백그라운드도 색깔 안먹고… 보라색이 뜬다면… 바텀을 superview에 맞춰주자…
- localization
    - csv를 파싱해서 localized 파일을 생성해주는 코드가 있댕~! 그러면 쉽게 바뀐다고 함~~~~ 효효

---

```jsx
protocol MyDelegate {
    func runDelegateMethod()
}

class ClassProtocolTest: MyDelegate {
    weak var delegate: MyDelegate? // 여기서 weak를 붙이는 이유는 retain cycle을 피하기 위함
    func runDelegateMethod() {}
}
```

하지만, 에러가 발생함!!

<aside>
💡 `'weak' must not be applied to non-class-bound 'MyDelegate'; consider adding a protocol conformance that has a class boun`

</aside>

위 문구는 `class`를 따르지 않는 프로토콜을 `weak` 변수로 선언해 사용할 때 발생하는 에러임 !

프로토콜은 클래스와 구조체, 열거형에 사용 가능함

앞에서 선언한 프로토콜은 클래스에서 사용되는지 아니면 구조체나 열거형에서 사용되는지 알 수 없기 때문에 `reference count`관리를 위해 사용되는 `unowned`이나 `weak` 키워드를 사용할 수 없는 것입니다.

→ 따라서 프로토콜이 class를 따르도록만 제한해주면 해결!~

```jsx
protocol MyDelegate: class { // 이렇게 class로!!
    func runDelegateMethod()
}
```

---

### CoreData의 race condition

- coredata는 생각보다 thread safe하지 않다
- forEach의 경우 클로저를 던진다라는 것을 유의해야 함
- 근데 for문이 아닌 forEach로 쓰면 여러 개의 thread로 돌아가게 되면서 이로 인해 race condition이 발생해서 가끔 앱이 죽는 현상이 일어났었따!!!
- 그래서 이참에 for문으로 돌리기도 하고 actor로 바꾸기로 했다

```swift
import UIKit

class Test {
    var num = 0
    
    func increment() async {
        num += 1
        print(num)
    }
}

let a = Test()
let arr = 0...1000

arr.forEach { _ in 
    Task { 
        await a.increment()
    }
}

//for i in arr {
//    Task {
//        await a.increment()
//    }
//}

// 실행하면 1234 10 11 12 567... 이런씩으로 이쁘게 안올라간다
```

```swift
import UIKit

actor Test {
    var num = 0
    
    func increment() async {
        num += 1
        print(num)
    }
}

let a = Test()
let arr = 0...1000

arr.forEach { _ in 
    Task { 
        await a.increment()
    }
}

//for i in arr {
//    Task {
//        await a.increment()
//    }
//}

// 이렇게하면 이쁘게 잘 올라감!
```

**갑자기 릴리즈버전을 올렸는데 릴리즈 버전만 앱이 죽는 현상이 일어났다면?**

- optimization level을 보고 변경하는 것을 추천
- 이 때, apple clang, compiler 각각에 대한 optimization이 있으므로 이를 유의할 것!

### **[Optimization Level](https://developer.apple.com/documentation/xcode/build-settings-reference#Optimization-Level)**

**Setting name:** `GCC_OPTIMIZATION_LEVEL`

- **이 환경 변수는 주로 C 및 C++ 코드 컴파일에 사용됩니다.**

Specifies the degree to which the generated code is optimized for speed and binary size.

- *None:* Do not optimize. [-O0] With this setting, the compiler’s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent—if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.
- *Fast:* Optimizing compilation takes somewhat more time, and a lot more memory for a large function. [-O1] With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple’s compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.
- *Faster:* The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. [-O2] With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.
- *Fastest:* Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. [-O3]
- *Fastest, Smallest:* Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. [-Os]
- *Fastest, Aggressive Optimizations:* This setting enables `Fastest` but also enables aggressive optimizations that may break strict standards compliance but should work well on well-behaved code. [-Ofast]
- *Smallest, Aggressive Size Optimizations:* This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. [-Oz]

### **[Optimization Level](https://developer.apple.com/documentation/xcode/build-settings-reference#Optimization-Level)**

**Setting name:** `SWIFT_OPTIMIZATION_LEVEL`

- **swift 컴파일에 필요**
- *None:* Compile without any optimization. [-Onone]
- *Optimize for Speed:* [-O]
- *Optimize for Size:* [-Osize]
- *Whole Module Optimization:* [-O -whole-module-optimization]

**⇒ 좀 더 테스트해보니까 진짜 coredata쪽 모듈만 swift optimization level을 .none으로 해야 됨… 진짜 뭐지 코어데이터? 진짜 어이없다….**
