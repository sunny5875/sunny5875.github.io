# 12-2. design-command pattern

디자인 패턴은 어떤 문제 상황에서 어떤 조건 하에서 문제에  부딫힐 수 있는데 이 때 문제를 변경에 유연하게 설계하는 것이 중요하고 대표적인 용어가 OCD임

확대에는 오픈되어있고 변경에는 닫혀있어야 한다

각자 해결한 방안들을 모아서 만든게 디자인 패턴

어떤 문제상황, context가 나오고 이런 상황에서는 이런식으로 설계를 해라~ 클래스다이어그램, 시퀀스 다이어그램이 나와 있음. 어딘가에서 변경이 생기고 아픙로도 생길 수 있는데 생길 때마다 코드를 고치면 유지보수가 들기에 코드를 안고치기 위해서는 변화가 생기는 부분은 캠슐화하고 공통적으로 추상화해서 다형성을 적용하면 되겠다!

strategy pattern : 만드는데 정렬할 수 있느 알고리즘에는 여러가지가 존재, 그 알고리즘이 계속 바뀔 수 있으므로 디자인 패턴을 쓰지 않고 쓴다면 코드를 매번 고쳐야 하므로 바뀌는 전략을 뽑아서 캡슐화하고 추상화해서 실제 사용하는 부분에서는 추상화딘 인터페이스를 가져서 위임을 시키도록 한다.

전략이나 알고리즘을 묶는 것인데 오늘은 명령을 묶는것

### 기능을 캡슐화로 처리하는 방법 이해

→ command patternr을 통한 기능의 캡슐화 방법 

ex) 만능 버튼 : 눌러지는 기능을 누르면 연결된 사물이 켜지는 일을 할 것, 버튼을 만들고 누르면 동작이 되도록 하고 싶다. 티비가 연결되면 티비가 켜져야 하고 램프가 연결되면 램프가 켜져야하는데 어떤 물건이냐에 따라서 코드가 바뀔 것

### 구현

button은 lamp를 맴버변수로 가지며 pressed함수를 통해서 위임해서 동작

### 문제점

- 변경이 생기면 유지보수 못하는 코드, 현재 버튼은 램프를 알고있는데 얘는 만능버튼이니까 라디오 등등도 다 연결이 되어야하는데 그때마다 버튼 클래스 코드가 계속 바뀐다
- 동작에 따라서 다른 기능을 하려고 변경하려면 새로운 기능이 추가될 떄마다 button 클래스를 수정해야 함

→ OCP 위반

Context, 문제점, 상황 : 버큰이 눌렀을 때 앞으로 다른 걸 연결하고 싶을 경우에는? 버튼의 기능을 런타임에 결정되도록 하려면?? 한번 누르면 램프를 키고 다시 누르면 꺼지고 등등 런타임에 그때그떄 바꾸려면??

: 대상과 동작방식 둘 다 바꾸고 싶다

대상이 바뀌어도 코드를 바꿔야 하고 동작방식을 바꿀려면 이렇게 코드를 작성해야하는데. Solid에서 o, 조건에 따라서 객체가 달라지는 코드가 나온다면 일반적으로 OCP 위반할 가능성이 크다

새로운 것이 추가되면 case가 늘어나기 떄문에 확장에 닫혀있다라고 볼 수 있다

추상화한 것만 알아서 호출해야 하는데 첫번째 처럼 설계하면 OCP에 위반하게 된다

### 해결방안

- 버튼이 눌렸을 때 수행될 기능(명령)을 캡슐화
    - 버튼은 기능을 캡슐화된 객체로 전달받음
    - 버튼이 눌리면 전달받은 객체를 호출함으로써 구체적 명령을 수행

![Untitled](12-2%20design-command%20pattern%20813b9506480c4f2d9def0511ed2afec4/Untitled.png)

- 일을 하는 대상은 구체적으로 알고 있으면 안 됨. 다 캡슐화시키고 버튼을 누를 때마다 동작방식도 다르게 하고 싶음. 일하는 부분도 추상화시켜야 한다.
- 버튼은 동작하는 대상을 바로 알면 안되고 동작방식 또한 바뀌므로 구체적인 동작방식도 알면 안된다.
- 버튼은 눌린 경우 구체적인 대상에게 동작하라고 명령을 내릴 것, 버튼 자신이 일하는 것이 아니라 어떤 대상한테 일을 해야 한다고 동작을 알려줌

버튼은 구체적인 대상은 모르고 명령을 보고 명령을 내림 -> pressed되면 명령을 내리고 명령 안에는 execute라는 함수가 있고 명령 종류가 많기에 커맨드를 상속받아서 클래스를 만듦

- 버튼은 명령이라는 인터페이스만 알면 된다.이 구체적인 명령이 실제로 일하는 대상과 연결되어 있어서 실제로 일하는 대상에 위임시킨다.

이벤트가 발생되는 대상 – 버튼

일하는 대상 – 다른 대상

→ 이벤트가 발생되는 대상과 일하는 대상을 분리시켜서 결합도를 떨어뜨림. 그냥 일을 해만 알고 있어야 하고 버튼은 명령에 대해서만 알고 있으며 명령에는 실행되는 기능이 있고 이를 상속받아서 구체적인 명령을 만들고 구체적인 명령은 구체적인 대상을 알고 있음. Command만 알고 있고 나머지 램프와 버튼은 모름.

버튼에 Setter를 두면 런타임에 동적으로 명령을 바꿀 수 있을 것

이벤트가 발생하면 일하는 대상에게 명령을 내리고 그 명령을 command로 만든다

cf. 이러한 상황은 주로 GUI, swing(자바의 GUI 라이브러리), 메뉴를 누르면 누가 일을 해주는데 구현할 때에는 메뉴 라이브러리를 가져와서 쓸 것이고 그 메뉴를 클릭하면 일을 하겠지만 다르 앱에서는 메뉴를 누르면 다른 일이 일어남

→ 버튼이 눌러졌을 때 하는 일들을 캠슐화한 것, 버튼의 커맨드는 다형성이 적용되어서 실제로 일하는 대상에 위임할 것 : OCP를 지킨다

Cf. 램프랑 커맨드랑 바로 연결하면 되는데 왜 커맨드를 사이에 끼어있나??

실제로 메뉴는 일하는 대상과 시키는 대상이 완전 별개이고 영향을 받으면 안된다. 램프와 알람과 버튼(일하는 애들,이벤트 발생하는 대상 모두 분리해야 한다) 일하는 애들도 누가 이미 만든 애일 수도 있기 때문에 분리해야한다. 램프는 원래 잘 하는데 버튼과 연결된다고 램프를 고치게 하면 안된다

버튼입장에서는 커맨드만 알고 있고 램프와 알람인 실제 일하는 대상도 고쳐질 필요가 없음

- 결합도를 떨어뜨리려면 레이어를 끼워넣어야 한다.

## Command Pattern

- 커맨드 패턴은 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 invoker와 실제로 기능을 실행하는 receiver 사이의 의존성을 제거(결합도 감소)
- 요구사항을 객체로 캡슐화할 수 있으며 다양한 요구사항을 넣을 수 있음
- 명령을 캠슐화하여 기능을 호출하는 애와 실행하는 애를 분리시켜서 서로를 모르게 하고 기능을 동적으로 바꿔도 영향을 받지 않도록 한다

## comand pattern 클래스 다이어그램

![Untitled](12-2%20design-command%20pattern%20813b9506480c4f2d9def0511ed2afec4/Untitled%201.png)

명령을 요청하는 invoker, 이벤트가 발생하는 대상 - 버튼

버튼에서 이벤트가 발생하면 어떤 메소드가 호출될 것,  실제 일하는 대상 – receiver

- invoker는 명령을 맴버변수로 가지고 있음.
- command는 실행될 명령에 대한 인터페이스
- concrete command는 구체적인 recevier를 맴버변수로 가지고 있고 command를 구현
- Invoker와 receiver는 서로 모르고 receiver는 기존의 행위를 잘 하고 잇는데 invoker와 연결되어서 어떤 동작을 할 수 있다. 동작하게 하려면 어떤 일을 하라고 하는 commend를 내릴 수 있음
- Receiver는 invoker, concrete command를 모르므로 없어도 원래 잘 돌아가는 클래스임
- 왼쪽과 오른쪽을 분리

### 시퀀스 다이어그램

![Untitled](12-2%20design-command%20pattern%20813b9506480c4f2d9def0511ed2afec4/Untitled%202.png)

(로봇 예제)

![Untitled](12-2%20design-command%20pattern%20813b9506480c4f2d9def0511ed2afec4/Untitled%203.png)

(tv 예제)

invoker : controller, command를 가지고 있는 명령할 클래스

receiver : tv, 실제로 기능을 수행할 클래스

command : command, 실행할 명령을 가지고 있는 인터페이스

concrete command :  command를 상속받아서 사용, mute command, power command