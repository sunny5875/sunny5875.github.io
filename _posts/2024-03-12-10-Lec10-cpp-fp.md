---
layout: post
title: 10. Lec10-cpp-fp
date: 2023-06-14 23:25:33 +0000
category: ProgrammingLanguage
---

ê³¼ì œ4ì— ëŒ€í•œ ìˆ˜ì—…

### Recursive structures

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 3.39.44.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.39.44.png)

- MLì—ì„œëŠ” expìœ¼ë¡œ recursive tructureì„ ì„ ì–¸í•´ì„œ abstract treeë¥¼ ë§Œë“¤ì—ˆì—ˆìŒ.
- eval í•¨ìˆ˜ëŠ” Expressionì„ ì¸ìë¡œ ë°›ì•„ì„œ integerë¡œ ë¦¬í„´í–ˆì—ˆìŒ

â†’ ì´ê±¸ ê³¼ì œì— íŒíŠ¸ê°€ ë˜ë„ë¡ ì¡°ê¸ˆì”© ë°”ê¿”ë³¼ê±°ì„

### Change how we do this

- expë¥¼ ë°›ì•„ì„œ intë¥¼ ë¦¬í„´í–ˆì—ˆëŠ”ë° ì§€ê¸ˆì€ **exp â†’ exp**ë¡œ í•´ë³´ì
    - general proposeì—ëŠ” multiple kind of resultê°€ ìˆì„ ìˆ˜ ìˆìŒ. int, clousre, bool ë“±ë“± íƒ€ì…ì„ evalì—ì„œë„ ë°›ì„ ìˆ˜ ìˆê²Œ expression typeìœ¼ë¡œ ë°›ì„ ìˆ˜ìˆë„ë¡ í•˜ì!
    - any expê°€ ì•„ë‹ˆë¼ value expressionì„ ë°›ì•„ì„œ ë”ì´ìƒ ì²˜ë¦¬ê°€ ë˜ì§€ ì•Šì€ íƒ€ì…ìœ¼ë¡œ ë¦¬í„´

```cpp
//old_eval.cc 
//+ stringí•¨ìˆ˜ë‘ is(Functions for check variants.)í•¨ìˆ˜ ì¶”ê°€ë¨, toStringí•¨ìˆ˜ë„ ì¶”ê°€ë¨
// eval: expr -> int
**int** eval(Expr e) {
    return std::visit(overload {
        [&](Const& i) { return i.val;},
        [&](box<struct Add>& a) {
          int i1 = eval(a->e1);
          int i2 = eval(a->e2);
          return i1+i2;
        },
        [&](box<struct Multiply>& m) {
          int e1 = eval(m->e1);
	        int e2 = eval(m->e2);
					return e1*e2;
        }, 
      }, e);
```

```cpp
// eval: expr -> expr
Expr eval(Expr e) {
    return std::visit(overload {
        [&](Const& i) { return e;},
        [&](box<struct Add>& a) {
          Expr e1 = eval(a->e1);
          Expr e2 = eval(a->e2);
          if (is<Const>(e1) && is<Const>(e2)) { // ë¬´ì¡°ê±´ constantì—¬ì•¼ í•˜ê¸° ë•Œë¬¸ì— isë¡œ ì²´í¬í•œ í›„ì— getí•´ì„œ ê°€ì ¸ì˜´
            Const i1 = std::get<Const>(e1);
            Const i2 = std::get<Const>(e2);
            Expr res(Const(i1.val+i2.val));
            return res;
          } else {
            throw std::runtime_error("Unexpected types for sub-expressions of Add");
          }
        },
        [&](box<struct Multiply>& m) {
          Expr e1 = eval(m->e1);
          Expr e2 = eval(m->e2);
          if (is<Const>(e1) && is<Const>(e2)) {
            Const i1 = std::get<Const>(e1);
            Const i2 = std::get<Const>(e2);
            Expr res(Const(i1.val*i2.val));
            return res;
          } else {
            throw std::runtime_error("Unexpected types for sub-expressions of Multiply");
          }
        }, 
      }, e);
}
```

- new_eval
    - base caseì‹œ return entire expression ex) Const(17)
    - recursive case
        - check variant: isí•¨ìˆ˜ë¡œ ì²´í¬
        - extract data: getìœ¼ë¡œ ì •í™•í•œ íƒ€ì…ìœ¼ë¡œ ê°€ì ¸ì˜´
        - return Expr: Exprì„ ë§Œë“¤ì–´ì„œ ë¦¬í„´

### Using new eval

```python
Expr e = Add(Const(-3), Const(2));
Expr res = eval(e);
Const ires = std::get<Const>(res);
std::cout << "Add(Const(-3), Const(2)):" << std::string(ires) << std::endl;
```

### Typical workflow

compile, evaluateê°€ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ í•œë²ˆ ë³´ìŸˆ

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 3.48.28.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.48.28.png)

1. parsing
    - expressionì´ grammerì— ë¬¸ì œê°€ ìˆë‹¤ë©´ íŒŒì‹± ì—ëŸ¬ê°€ ë‚  ê±°ì„
2. type checking
    - íŒŒì‹±ì´ ëœë‹¤ë©´ ê·¸ë‹¤ìŒì—ëŠ” syntax treeë¥¼ ë§Œë“¤ê±°ì„
    - íƒ€ì…ì²´í‚¹ì„ í•´ì•¼í•˜ëŠ”ë° ë§Œì•½ì— ì—ëŸ¬ê°€ ë‚œë‹¤ë©´(+ì¸ë° boolì„ ë³´ë‚´ë©´?? ) ì—ëŸ¬ê°€ ë‚ ê±°ì„
3. rest of implementation
    - íƒ€ì…ì—ëŸ¬ê°€ ì•ˆë˜ë©´ executionì´ ë  ê±°ì„, astë¥¼ ë°›ì•„ì„œ resultë¥¼ ë§Œë“¤ê¸°ìœ„í•´ ì‹¤í–‰í•  ê²ƒ

### Interpreter or compiler

- rest of implementationì€ AST(abstract syntax tree)ë¥¼ ë°›ì•„ì„œ resultë¥¼ ë§Œë“¤ê¸°ìœ„í•´ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•  ê²ƒ
- PL Bë¥¼ êµ¬í˜„í•˜ëŠ” ì ‘ê·¼ë°©ì‹
    - PL BëŠ” target language, ìœ„ì˜ ì˜ˆì‹œëŠ” MLì´ ë  ê±°ì„, ê³¼ì œì—ì„œëŠ” MUPL
    - **interpreter(evaluator, executor)** in A
        - evaluateí•˜ê¸° ìœ„í•´ì„œ interpreterë¥¼ ë§Œë“¤ì–´ì•¼í•˜ëŠ”ë° ì–˜ëŠ” ë‹¤ë¥¸ ì–¸ì–´ Aë¡œ ì‘ì„±ë˜ì–´ì•¼ í•¨
        - Bë¥¼ ë°›ì•„ì„œ Bë¥¼ ìƒì„±
            - new evalì€ expressionì„ ë°›ì•„ì„œ const expressionì„ ë¦¬í„´
    - **compiler(translator)** in A to C
        - ==  compilerì— cì–¸ì–´(ë¨¸ì‹ ëŸ¬ë‹ ì–¸ì–´, ì–´ì…ˆë¸”ë¦¬, ë°”ì´íŠ¸ì½”ë“œ)ë¡œ ë°”ê¿ˆ
        - translation must preserve meaning(equivalence)
- Language **A**
    - metaLanguage
    - implement compiler or interpretor
    - Aì™€ Bë¥¼ ì˜ êµ¬ë³„í•´ì•¼ í•¨

### Reality more complicated

- evaluation(interpreter) and translation(compiler)ëŠ” optionì´ì§€ë§Œ ë‹¤ë¶€ë¶„ ëª¨ë‘ ê°€ì§€ê³  ìˆìŒ
    - í˜„ì‹¤ì—ì„œ compiler, interpreterì€ êµ¬ë³„í•˜ê¸° ì–´ë ¤ì›€. ì™œëƒë©´ ê°™ì´ í•©ì³ì ¸ ìˆëŠ” ê²½ìš°ê°€ ìˆê¸° ë•Œë¬¸

ex) 

- java ì»´íŒŒì¼ëŸ¬: ìë°” ì½”ë“œâ†’ ë°”ì´íŠ¸ì½”ë“œ
- ë°”ì´íŠ¸ì½”ë“œë¥¼ virtual machine(interpretor)ì„ ì´ìš©í•´ì„œ ë§Œë“¦
- ë°”ì´íŠ¸ì½”ë“œê°€ ìì£¼ ì‹¤í–‰ëœë‹¤ë©´ ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” ê·¸ ë¶€ë¶„ì„ ë°”ì´íŠ¸ì½”ë“œë¡œ ë°”ê¿”ì„œ ì‹¤í–‰ë¨

ex)

- ì¹©ë„ interpreter for binary
- fetch opcode and execute in hardware â€¦ ê°™ì€ ë™ì‘ì„ í•˜ê¸° ë•Œë¬¸

### Sermon

> interpreter vs compiler vs combinationì€ **particular language implementation**ì´ì§€ **language definition**ê°€ ì•„ë‹˜
> 
- ~~compiled language. interpreted language ì´ëŸ° ê±´ ì—†ë‹¤ëŠ” ë§ì„~~

- rest of implemnationì„ interpreterë¡œ í•´ë³´ì!

### Skipping parsing

- PL Aì—ì„œ PL Bë¥¼ êµ¬í˜„í•  ë•Œ parsingì„ ìƒëµ
    - B programmerê°€ PL Aì—ì„œ ASTë¥¼ ë°”ë¡œ ì“´ë‹¤ëŠ” ì†Œë¦¬
    - embed B programs as tree in A

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 4.03.35.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.03.35.png)

- PL B(arithmetic language)ì´ê³  AëŠ” c++ì¸ë° expr objectë¥¼  c++ ìƒì„±ìë¡œ ë§Œë“¤ì—ˆìŒ
- íŒŒì‹±ì„ ìŠ¤í‚µí•˜ê³  Parse treeëŠ” Aì—ì„œ ë°”ë¡œ ë§Œë“¤ì—ˆë‹¤ë¼ê³  ê°€ì •

â†’ ì‚¬ì‹¤ Bì—ì„œ astì—ì„œ ë§Œë“¤ì§€ë§Œ A(c++)ì—ì„œ ë°”ë¡œ ìƒì„±ë˜ê²Œ!

<aside>
ğŸ‘‰ metalanguage A ëŠ” c++,  bëŠ” arithmetic language, c++ì—ì„œ ìƒì„±í•˜ê³  evalaute, interpreterì€ eval

</aside>

### What we know

- Bë¥¼ c++ structë¥¼ ì´ìš©í•´ì„œ abstract syntax languageë¥¼ ì •ì˜
- B programì„ ë°”ë¡œ c++ ìƒì„±ìë¥¼ ì´ìš©í•´ì„œ c++ë¡œ ì‘ì„±í•  ê±°ì„
- arithmetic ì–¸ì–´ë¼ê³  ë¶€ë¥´ê¸° ë³´ë‹¤ëŠ” bë¥¼ MUPLì´ë¼ê³  ë¶€ë¥¼ ê±°ì„
    - make up programming language
- ì¤‘ìš”í•œ ì 
    - interpreterëŠ” ì£¼ì–´ì§„ inputì´ **legal AST for B**ë¼ê³  ê°€ì •
    - interpreterëŠ” recursive resultê°€ ë§ëŠ” typeì¸ì§€ ê¼­ ì²´í¬í•´ì•¼ í•¨ ì•„ë‹ˆë¼ë©´ exception

### Legal ASTs

- ASTì˜ syntaxëŠ” c++ compilerê°€ í™•ì¸í•´ì¤„ ê²ƒ
- eval functionì— illegal ASTê°€ ì˜¬ ìˆ˜ ì—†ë‹¤ê³  ê°€ì •

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 4.09.22.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.09.22.png)

### Interpreter result

- interpreterì˜ ê²°ê³¼ëŠ” valueê°€ ë˜ì–´ì•¼ í•¨
    - evaluate itselfì¸ ê²Œ valueë¼ê³  í–ˆìœ¼ë‹ˆê¹Œ ë” evaluateë  ê²Œ ì—†ê±°ë‚˜ evaluate itselfì¸ ì•  ì—¬ì•¼ í•¨
    - MUPLì—ì„œëŠ” int, pair, closures, aunitì´ value

### Example

ast nodeì— ë‘ê°œì˜ structì¸ Bool, ifThenElse ì¶”ê°€í•´ë³´ì

Q. legal ASTë¼ê³  ê°€ì •í–ˆì„ ë•Œ evalauation ì‹œ ì–´ë–¤ ê±¸ ì²´í¬?

A. ex) add boolean

- detectë¥¼ ë¬´ì¡°ê±´í•´ì„œ error messageë¥¼ ë³´ì—¬ì¤˜ì•¼ í•¨
- íŠ¹ì •í•œ ê°’ì´ í•„ìš”í•  ë•Œ recursive resultë¥¼ ì²´í¬

```cpp
//Boolì´ë‘ ifThenElseê°€ ast nodeì— ì¶”ê°€ë¨
Expr eval(Expr e) {
    return std::visit(overload {
        [&](Const& i) { return e;},
        [&](Bool& i) { return e;}, // boolì€ valueë‹ˆê¹Œ ê·¸ëƒ¥ ìê¸°ë¥¼ ë¦¬í„´
        [&](box<struct Add>& a) {
          Expr e1 = eval(a->e1);
          Expr e2 = eval(a->e2);
          if (is<Const>(e1) && is<Const>(e2)) {
            Const i1 = std::get<Const>(e1);
            Const i2 = std::get<Const>(e2);
            Expr res(Const(i1.val+i2.val));
            return res;
          } else {
            throw std::runtime_error("Unexpected types for sub-expressions of Add");
          }
        },
        [&](box<struct Multiply>& m) {
          Expr e1 = eval(m->e1);
          Expr e2 = eval(m->e2);
          if (is<Const>(e1) && is<Const>(e2)) {
            Const i1 = std::get<Const>(e1);
            Const i2 = std::get<Const>(e2);
            Expr res(Const(i1.val*i2.val));
            return res;
          } else {
            throw std::runtime_error("Unexpected types for sub-expressions of Multiply");
          }
        }, 
        [&](box<struct IfThenElse>& i) {
          Expr e1 = eval(i->e1);
          if (is<Bool>(e1)) { // boolì¸ì§€ ì²´í¬ ì•„ë‹ˆë¼ë©´ exception
            Bool b = std::get<Bool>(e1);
            if (b.val) {
                Expr e2 = eval(i->e2); // trueì¼ ë•Œë§Œ e2ë¥¼ evaluate
                return e2;
            } else {
                Expr e3 = eval(i->e3); // falseë©´ e3ì„ evaluate
                return e3;
            }
          } else {
            throw std::runtime_error("Unexpected types for condition of IfThenElse");
          }
        },
      }, e);
}
```

### Dealing with varaible

- ì´ ë•Œê¹Œì§€ì˜ interpreterì€ variableê°€ ì—†ì—ˆìŒ
    - ex) let exprewssion, function with argument ë“±ë“± ê°™ì€ ê²ƒë“¤
    - MUPLì€ let, function, var ë“±ë“± ë‹¤ ê°€ì§€ê³  ìˆìŒ
- environment
    - c++ stringì„ variable(key)ì— value(Expr)ë¥¼ map
    - eval ì‹œ environmentë¥¼ ë°›ìŒ
        - environmentë¥¼ ì¸ìë¡œ ë³´ëƒ„
        - ëŒ€ë¶€ë¶„ subexpressionì€ same enviromentì´ì§€ë§Œ let expressionì€ bodyëŠ” larger environmentì—ì„œ evaluateí•´ì•¼í•¨
        - variable expressionì€ environmentì—ì„œ variableì„ Look up
- eval
    - empty environmentë¥¼ ìƒì„±
    - eval_under_env recursive functionì„ ë¶€ë¥´ê³  ì´ ë•Œ ì¸ìë¡œ envë¥¼ ì „ë‹¬

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 4.31.19.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.31.19.png)

ex)

- functionì´ë‚˜ clousreì´ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ”ë° closureì€ valueì§€ë§Œ functionì€ valueê°€ ì•„ë‹ˆê¸°ì— clousureë¡œ ë¦¬í„´í•´ì•¼ í•¨
- foo(a)ë¼ë©´ ì–˜ëŠ” fun(â€fooâ€, a, code)ì´ë ‡ê²Œ ë˜ê³  ì–˜ëŠ” closureì„ ë¦¬í„´
- call(e1, e2)ë¼ë©´ e1ëŠ” í´ë¡œì €ë¡œ ë¦¬í„´í•˜ê³  extend envionment in arugent mappingí•˜ê³ ë‚˜ì„œ closure bodyë¥¼ under the enviroment

### The best part

ê³¼ì œì—ì„œ ê°€ì¥ í¥ë¯¸ë¡œìš´ ë¶€ë¶„ì´ first-class clousreì„ êµ¬í˜„í•˜ê³  closureì„ ì‹¤í–‰í•˜ëŠ” ê±°ë˜

closureì€ lexical scopeì„ ì§€ì›í•  ì˜ˆì •

### Higher order function

- closureì„ êµ¬í˜„í•˜ê³  ì–˜ë¥¼ ì¸ìë¡œ ë³´ë‚¼ë ¤ë©´ envê³¼ ì½”ë“œë¥¼ ì €ì¥í•´ì•¼ í•¨
    
    ![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 4.34.30.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.34.30.png)
    
    - stringê³¼ exprìœ¼ë¡œ mappingëœ envë¥¼ ê°€ì§
    - ì‹¤ì œ function ë„ ê°€ì§€ê³  ìˆìŒ
- functionì„ evaluate
    - functionì€ valueê°€ ì•„ë‹ˆë¯€ë¡œ closureì„ ë¦¬í„´
    - functionê³¼ current enviroment(evaluate to closure)ì„ ê°€ì§„ closureì„ ë¦¬í„´

### Function calls

`call(e1,e2)`

ê³¼ì œì—ëŠ” callë¼ëŠ” structure ì¡´ì¬ contain two subexpression

- evalì´ callì„ ë§Œë‚˜ë©´ current environmentì—ì„œ e1ì„ evaluateí•´ì„œ closureì„ ë°›ì•„ì•¼í•¨
    - e1ì´ closureì—ì„œ evaluateë˜ì§€ ì•Šìœ¼ë©´ std runtime errorë¥¼ ë°œìƒì‹œì¼œì•¼í•¨
- current enviromentì—ì„œ e2ë¥¼ evaluate
    - ê³¼ì œì—ì„œì˜ ëª¨ë“  í•¨ìˆ˜ëŠ” ì‹±ê¸€ ì¸ì(e2)ë¥¼ ë°›ê³  ìˆìŒ
- bodyë¥¼ evalaute ì‹œ closureâ€™s enviromentì—ì„œ evalaute
    - function argument nameê³¼ arugment valueë¥¼ map
    - for recursionì„ ìœ„í•´ function nameê³¼ closureì„ map
- lexical scopeìœ¼ë¡œ ê³„ì‚°í•´ì¤„ ê²ƒ

```python
Expr clos = eval_under_env(call->funExpr, env); // closure
            Expr argument = eval_under_env(call->actual, env); //ì¸ì

            if (is<Closure>(clos)) {
                box<struct Closure> closure = std::get<box<struct Closure>>(clos);
                Fun f = closure-> f;
                std::map<string, Expr> funEnv = makeNewEnvFrom(closure->env);
                if (f.funName != "") {
                    funEnv.insert_or_assign(f.funName, closure);
                }   
                funEnv.insert_or_assign(f.argName, argument);

                Expr result = eval_under_env(f.body, funEnv);
                return result;
            } else {
                throw std::runtime_error("Unexpected types for sub-expressions of Call");
            }
```

### is that expensive?

evalì´ funì„ ë³´ë©´ closureì„ ë§Œë“¤ê³  ê·¸ ë•Œ envë¥¼ ë§Œë“¤ì–´ì•¼ í•˜ëŠ”ë° ì´ê²Œ ë¹„ìŒ€ ìˆ˜ ìˆê² ì§€ë§Œ MUPLê°™ì€ ê±°ëŠ” ë¬¸ì œê°€ ì•ˆë˜ê² ì§€ë§Œ real programming languageì—ëŠ” ì–´ë–¨ê¹Œ?

- build closure
    - ì‹œê°„ ê±°ì˜ ë“¤ì§€ ì•ŠìŒ
    - two fieldë§Œ ê°€ì§€ê¸° ë•Œë¬¸
- space to sore closure
    - might be large
    - closure ë§Œë“œëŠ”ë°ëŠ” ì‹œê°„ì€ ì ê²Œ ë“¤ì§€ë§Œ spaceëŠ” ë§ì´ í•„ìš”í•´ì„œ ëŸ°íƒ€ì„ ë„˜ëŠ” ê²½ìš°ë„ ì¡´ì¬

â†’ ì‹¤ì§ˆì ìœ¼ë¡œëŠ” closure ìƒì„± ì‹œ ë‹¤ ì €ì¥í•˜ì§€ ì•Šê³  free variableë§Œ ì €ì¥í•¨

- **free variable**
    - not defined in function but use in function
    - variable that occur not counting shadowed uses of the same varaible name
    - should be capture

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2023-06-10 á„‹á…©á„’á…® 4.50.34.png](10%20Lec10-cpp-fp%2021955a3e0be144e1806a9c252ce4336a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.50.34.png)

### Computing free variables

Q. interpreterê°€ closureì„ ë§Œë“¤ ë•Œë§ˆë‹¤ code bodyë¥¼ ë¶„ì„í•´ì•¼ í•˜ëŠ” ê±´ê°€?

A. no evaluation ì „ì— free varaibleì„ ì°¾ì•„ì„œ store!

- ëŸ°íƒ€ì„ì— ë­ê°€ free variableì´ê³  ì•„ë‹Œì§€ëŠ” ëª¨ë“  ì½”ë“œë¥¼ ë¶„ì„í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ì–´ë ¤ìš´ í¸
- ì»´íŒŒì¼ íƒ€ì„ì— ì»´íŒŒì¼ëŸ¬ê°€ computation free varaibleí•´ì„œ storeí•˜ëŠ” ê±°ëŠ” ì–´ë µì§€ ì•Šì€ í¸

â†’ naive store entire environment approachë³´ë‹¤ building a closureì€ ë” ë§ì€ ì‹œê°„ì´ ê±¸ë¦¬ì§€ë§Œ spaceëŠ” ì ê²Œ ì”€

- free variable ìˆ˜ì— ë¹„ë¡€, ë‹¤ë¥¸ optimizationë„ ê°€ëŠ¥

### Compiling higher-order functions

Q. ê³¼ì œì—ì„œëŠ” evalí•¨ìˆ˜ë¥¼ interpretatorë¡œ í•˜ê²Œ ë  ê±´ë° lexical scope, closureì„ compiler based languageì—ì„œ í•œë‹¤ë©´ ì»´íŒŒì¼ì€ low level codeë¡œ ë°”ê¿€ ë•Œ lexical scopeì´ë‚˜ closureì„ ì§€ì›í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì´ê±¸ ì–´ë–»ê²Œ ìœ ì§€í• ê¹Œ?

A. 

ì¸í„°í”„ë¦¬í„°ëŠ” keep the env in mapí•˜ë©´ ë˜ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ì˜ ê²½ìš°, ì–´ì…ˆë¸”ë¦¬ ê°™ì€ low level codeëŠ” í´ë¡œì ¸ê°€ ì—†ê¸°ì— envë¥¼ relyí•  ìˆ˜ ì—†ìŒ

- compile functionì€ extra explicit argumentì¸ enviromentë¥¼ ë°›ëŠ” **regular function**ì„ ìƒì„±
    - ëª¨ë“  free variableì€ enviroment argumentë¥¼ ì´ìš©í•´ì„œ lookupí•´ì„œ ì‚¬ìš©

```cpp
// ML ì½”ë“œ
fun foo(x) = x+y

//ì–´ì…ˆë¸”ë¦¬ê°€ c++ì¸ ê±¸ë¡œ ê°€ì •
// lexical scope, closure semanticì„ ì´ë ‡ê²Œ ë§Œì¡±
int foo(int x, std::map<std::string, Value> **env**) { 
	return x + convertToInt( **env.loopup("y")**);
}
```

### Macros, updated

- ìš°ë¦¬ê°€ êµ¬í˜„í•´ì•¼í•˜ëŠ” ì–¸ì–´ì˜ ì ‘ê·¼ ë°©ì‹
    - implement PL B in PL A
    - skip parsing by writing PL B program directly in terms of PL A constructor
    - interpreter written in A recursively evaluate

â†’ ì´ì œ í• ê±°ëŠ” macroë¡œ languageì˜ syntaxë¥¼ í™•ì¥ì‹œí‚¤ê³  ì‚¬ìš©í•´ë³¼ ê±°ì•¼!

### What is a macro

```cpp
#define ADD(a,b) (a+b)
int main() {
int a = 10;
int b = 20;
return ADD(a,b);
}
```

- **macro definition**
    - how to transform some new syntax into different syntax in the source language
    - ì•„ì£¼ ê°„ë‹¨í•œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´
    - c++ì—ì„œì˜ ë§¤í¬ë¡œì—ì„œëŠ” premitiveì„ not complicate semantic
    - one syntax â†’ another macro syntax in c code
        - Add(a,b)ë¥¼ c++ syntaxì¸ (a+b)ë¡œ ë³€ê²½
- macroë„ syntatic sugarë¼ê³  ë³¼ ìˆ˜ ìˆìŒ(codeê°€ ë°”ë€Œì–´ì„œ evaluateë˜ë‹ˆê¹Œ!)
- Macro system
    - macroë¥¼ ì •ì˜í•˜ëŠ” programming languageì„
    - ë§¤í¬ë¡œ ê°œë…ì„ ì•Œì•„ì•¼ ê³¼ì œë¥¼ í•  ìˆ˜ ìˆì§€ë§Œ ë””í…Œì¼ê¹Œì§€ëŠ” ì•Œ í•„ìš”ëŠ” ì—†ëŒ€
    - syntaxëŠ” cì™€ ì•„ì£¼ ë¹„ìŠ·í•¨
    - syntax â†’ target source code
- macro expansion
    - process of rewriting the syntax for each macro use
    - compileë„ ë˜ê¸° ì „ì— ë°”ë€œ!!

```cpp
#define ADD(a,b) (a+b)
int main() {
int a = 10;
int b = 20;
return ADD(a,b);
}
```

```cpp
int main() {
int a = 10;
int b = 20;
return (a+b);
}
```

cf. ë§¤í¬ë¡œ vs ì¸ë¼ì¸? ì¸ë¼ì¸ì´ ëŒ€ë¶€ë¶„ ë¬´ì¡°ê±´ ì¢‹ëŒ€, ì¸ë¼ì¸ìœ¼ë¡œ ëª»í•˜ëŠ” ê±°ë§Œ ë§¤í¬ë¡œë¡œ í•˜ëŠ” ê²Œ ì¢‹ëŒ€, ê·¸ê±°ë§Œì˜ syntaxê°€ ì¡´ì¬í•œë‹¤ê³  í•˜ë„¤ì—.

ADD(10,20) * 3 â‡’ 10+20*3ì´ëŸ° ì‹¤ìˆ˜ê°€ ë§¤í¬ë¡œì—ì„œ ì¼ì–´ë‚˜ë‹ˆê¹Œ ì¸ë¼ì¸ì´ ì¢‹ëŒ€

ì‹¤í–‰ ì¤‘ê°„ì— ë¡œê·¸ë¥¼ ì°ëŠ” ê²ƒë„ ë§¤í¬ë¡œë§Œ í•  ìˆ˜ ìˆëŒ€

### Put it together

- PL A(c++) functionì„ PL B abstract syntaxë¥¼ ìƒì„±í•˜ëŠ” PL B macroë¼ê³  ë³¼ ìˆ˜ ìˆìŒ!!
- AST MUPLì„ ë°”ë¡œ C++ì—ì„œ í•˜ê¸°ì— macroëŠ” extend syntax of language and generate target language source code(MUPL) when compile before

c++ function â†’ MUPL language â†’ define MUPL function

â‡’ macrosì²˜ëŸ¼ ë™ì‘í•˜ëŠ” ê±° ì•„ë‹ê¹Œ? ëŸ°í•˜ê¸° ì „ì— applyë˜ë‹ˆê¹Œ!!

way to create MUPL by calling constructor AST nodeì¸ë° ì´ë ‡ê²Œ ìƒê°í•˜ë©´ c++ functionì€ return MUPL languageì´ê³  use defining MUPL program

- PL B programì€ macroë¥¼ ì‚¬ìš©
- interpreterë‚˜ struct definitionì€ ë°”ë€ŒëŠ” ê²Œ ì—†ìŒ
- programiming ideiom

```cpp
//macroì¸ë° addThree = MUPL astë¥¼ ë§Œë“œëŠ”ë° 1+2+3ì„ í•˜ëŠ” astë¥¼ ë¦¬í„´
Expr addThree(int a, int b, int c) {
	Expr e = Add(Const(a), Add(Const(b), Const(c))); // c++í•¨ìˆ˜ì§€ë§Œ MUPLë¡œ ë°”ê¿”ì¤Œ
	return e;
}

int main() {
	Expr e4 = addThree(1, 2, 3);
	res = eval (4);
	ires = std::get<Const>(res);
	std::cout << toString(e4) <<": " << std::string(ires)<< std::endl; // const(6)
};
/*
Add(Const(1), Add(Const(2), Const(3))): Const(6)
*/
```

```cpp
//addFromToì •ì˜ì‹œ recursiveë¥¼ ì“°ì§€ ì•ŠëŠ”ë‹¤ë©´??
Expr addFromTo(int from, int to) {
	Add add(from,0);
	add.e2 = Add(from+1, 0);
	add = add.e2;
	add.e2 = Add(from+2, 0);
	...
}

//recursiveë¥¼ ì“´ë‹¤ë©´??
Expr addFromTo(int from, int to) {
    if(to==from+1) {
        return Add(Const(from), Const(to));
    } else if(to>from+1) {
        return Add(Const(from), addFromTo(from+1, to));
    } else { // from >= to
        throw std::runtime_error("from >= to");
    }
}

int main() {
	Expr e5 = addFromTo(0,10);
	res = eval (e5);
	ires = std::get<Const>(res);
	std::cout << toString(e5) <<": " << std::string(ires)<< std::endl; //const 55ê°€ ë  ê²ƒ
}
/*
Add(Const(0), Add(Const(1), Add(Const(2), Add(Const(3), Add(Const(4), Add(Const(5), 
Add(Const(6), Add(Const(7), Add(Const(8), Add(Const(9), Const(10))))))))))): Const(55)
*/
```

### Hygiene issue(cleaness)

```cpp
#define RUN_FOREVER(code) while (0) {\
int abc;\
// do somthing with the varaible\
code;\
}
```

- **hygiene issue**
    - shadowing variable when using local variable in macros
    - ë³€ìˆ˜ ì´ë¦„ì— PREFIX_abcë¼ê³  ë¶™ì—¬ì„œ í—·ê°ˆë¦¬ì§€ ì•Šë„ë¡ í•˜ëŠ” ë°©ë²•ì´ ìˆì§€ë§Œ ê·¸ë˜ë„ ì–´ë µëŒ€!!(ê·¸ë˜ë„ ë³€ìˆ˜ì´ë¦„ì´ ê°™ì„ ìˆ˜ ìˆì„ ê±°ì„)
        
        â†’ ì¸ë¼ì¸ì„ ì“°ì!
        
    - í•˜ì´ì œë‹‰ì´ë ¤ë©´ ì¶©ëŒ ì‹œ ë§¤í¬ë¡œ ì‹œìŠ¤í…œì´ ë³€ìˆ˜ì´ë¦„ì„ automaticìœ¼ë¡œ ë°”ê¿”ì¤˜ì•¼ í•¨
    - c++ì€ ìœ„ì²˜ëŸ¼ ë³€ìˆ˜ ì´ë¦„ì´ ì¶©ëŒë‚˜ê¸° ë•Œë¬¸ì— macroê°€ hygienicì´ ì•„ë‹˜
    - gccëŠ” í•˜ì´ì œë‹‰ì´ë˜