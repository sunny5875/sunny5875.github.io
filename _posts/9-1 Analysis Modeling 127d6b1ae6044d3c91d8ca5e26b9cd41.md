# 9-1. Analysis Modeling

이떄까지 배운건 소프트웨어가 머고 소공이 머고 프로세스, 프로젝트 관리, 품질보증을 관리해줘야 한다

주로 프로세스에 대해서 언급하는데 요구사항분석을 하고 있음. 요구사항과 분석을 나누기도 하고 합치기도 하는데 우리 수업에서는 같은 단계이지만 나눠서 보고 있고 요구사항찾는 거는 유스케이스 다이어그램으로 찾았고 찾은 것을 분석하는 것은 오늘부터!

# UML 모델링 과정

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled.png)

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%201.png)

요구사항을 찾는다는 것은 사용자가 우리에게 의뢰한 시스템이 원하는 기능, 사용하는 사례를 찾아내는 것, 사용자가 무엇을 원하는지, 시스템으로 하고자하는게 먼지, 기능 등을 찾아내는 것, 유스케이스 다이어그램으로 모델링하고 이걸로 모델링을 하면 기능들만 나오고 구체적인 내용을 알 수 없으므로 명세서가 같이 나옴. 명세서가 나오면 기능을 찾게 되는 것-> 기능적인 요구사항

요구명세서에서 비기능적인 요구사항도 들어갈 수 있음(3초 이내에 해주세요, 365일 다운되지 않게 해주세요 등등…)그것도 명세서에 기록될 것

요구사항 분석에서 유스케이스 다이어그램과 요구명세서, 이 두 개로 분석단계로 넘어가면 주로 명세서를 보고 작업함

- 클래스의 후보를 찾음 -어려우므로 방법론이 정말 많지만 그 중에서 한가지 방법을 사용할 것

→ 클래스 후보를 가지고 개념적 클래스 다이어그램(분석 클래스 다이어그램)을 만들고 여기서 완성이 안되기에 시퀀스 다이어그램을 그림(기본적으로 그림) 상태가 중요하다면 상태 다이어그램, 아니면 엑티비티 다이어그램 등등으로 보충하면서 클래스 다이어그램을 만듦

⇒ **개념 클래스 + 시퀀스 -> 클래스 다이어그램**

# 분석 모델

: 요구사항과 분석, 요구 분석이라고 함

### 분석 단계의 목표

- 요구사항을 충족시킬 수 있도록 시스템의 구성요소(what)을 파악하는 것을 목표

요구사항단계에서 사용자가 원하는 what을 찾지만 얘는 기능적인 what이고 분석단계에서도 what이지만 시스템의 구성요소의 what 즉 사용자가 원하는 시스템을 구성하는 what,  클래스를 찾음, 단위가 더 작음

→ 요구사항 단계에서는 유스케이스를 찾는 것 분석 단계에서는 클래스를 찾는 것

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%202.png)

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%203.png)

- 후보 클래스를 찾아서 개념적 클래스 다이어그램,분석 클래스 다이어그램을 만들어낸다
    
    시스템을 구성할 클래스를 도출하고 이렇게 도출된 클래스를 요구사항을 만족시켜야 한다.
    

→ 분석단계 목적은 분석 클래스 다이어그램을 완성하는 것

## 분석 모델의 구성요소

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%204.png)

근데 분석 클래스모델은 정적, 구조적인 관점밖에 못보기에 동적인 관점을 위해 액티비티 다이어그램도 그릴 수 있지만 주로 유스케이스 실현모델, 시퀀스 다이어그램을 사용함

클래스, 시퀀스 다이어그램은 반드시 그려야 함

분석단계에서 찾아내는 것들은 요구사항에서 찾아낸 유스케이스를 만족시키는 클래스를 찾는 것이 목표!

분석단계에서 시퀀스 다이어그램은 유스케이스를 실제로 실현하는가 안하는 가를 모델링하는 것

명세서에서 흐름이 있고 그 흐름을 시퀀스로 그림. 그말은 실제로 실현한다는 의미 동적인 관점. 이므로 유스케이스 실현 모델이라고 한다

클래스 모델은 클래스와 클래스 간의 관계를 보여주는데 유스케이스 실현 모델은 객체들간의 실제 상호작용을 보여준다. cf. 설계단계에 나오면 설계 유스케이스 실현모델임

**요구사항 정의 및 분석단계의 모델/다이어그램과 목적**

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%205.png)

요구 단계에서는 유스케이스 모델(다이어그램)과 명세서가 나와서 시스템의 기능적 요구사항을 정의함

분석단계에서는 유스케이스를 만족시키기 위해서 필요한 분석 클래스와 분석 클래스 간의 관계를 분석 클래스 다이어그램으로 만들고 클래스 다이어그램에서 나온 객체들이 어떻게 상호작용하는지 그것으로 각 유스케이스가 어떻게 실현되는지를 동적으로 보여준다.

→ 클래스 다이어그램과 시퀀스 다이어그램을 만든다.

## 분석 클래스의 유형

경계, 제어, 엔티티 클래스를 찾아내서 각 속성과 기능을 찾고 관계를 찾아내는 것

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%206.png)

요구사항 찾은 뒤에 명세서와 유스케이스 다이어그램을 보고 클래스 후보를 선정해야하는데 방법이 매우 다양함

Ex) c언어는 함수가 매우 다름. 자바나 이런 것들은 함수보다 더 큰 단위이기에 문제를 주고 시스템을 구현하라고 한다면 클래스를 찾을 때 개발자마다 다름

여러가지 방법론이 있고 가장 기본적인 것은 명사를 찾으면 클래스 후보, 동사는 클래스의 액션, 명사는 속성 등등 으로 찾는 방법이 존재 지금하는게 가장 많이 하는 방법

- 소프트웨어는 결과적으로 **ui, 일하는 부분과, 어딘가 영속적으로 파일이나 디비에 저장**해야 함

→ 1) 외부와 상호작용하는 **경계 클래스(유저, 디바이스, 시스템 인터페이스 중 하나)**

2)**실제 일처리해주는 부분 비지니스 클래스(제어 클래스)**

3) **어느 정보들이 영속적으로 저장되는 엔티티 클래스**

- 클래스 후보를 이 세가지 유형으로 찾는 방법, 그리고 나서 필요한 데이터 타입 클래스를 찾아감
- 경계 클래스끼리 하다가 제어 클래스에게 요청, 제어 클래스가 엔티티 클래스에게 요청(단, 제어가 엔티티로 바로 요청은 불가, 경계→제어→엔티티)

### 분석 클래스 모델 조직화

클래스를 찾게 되면 엄청 많이 나오므로 이것을 패키지로 구조화

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%207.png)

패키지 설계를 하면 레이어(설계 단계에서는, 층,티어)을 나누게 됨. Ui(경계 클래스), business layer(제어 클래스), 영속성 처리해주는 entity layer

- 소프트웨어를 크게 보면 이렇게 세개의 층으로 구성되어있고 이걸 물리적으로 **deploy할 때에는 tier**라고 한다.**ui단, 비지니스단, entity단 으로 구성**
- 클래스가 나오면 레이어로 논리적으로 관계있는 것들을 더 큰 덩어리인 패키지로 묶는다
- 레이어를 쪼갰을 때 ui layer, business/control layer, entity/persistency layer인데 ui가 비지니스단에게 일을 요청하고 비지니스가 일하다가 entity단으로 감. 건너뛸 수 없음. Ui는 액터와 상호작용하고 ui끼리는 가능하고 비지니스가 필요하다가 엔티티로 갈 수 있지만 ui는 엔티티로 바로 갈 수 없음.
    
    경계클래스끼리 하다가 제어 클래스한테 요청, 제어 클래스가 엔티티 클래스 에게 요청, 제어가 엔티티로 바로 요청하지 못함
    
- 레이어가 나눠지는 것은 소프트웨어의 기본

시퀀스로 표현하자면 엑터는 ui단에게 요청 -> 액터는 바로 control(business)로 갈 수 없고 인터페이스로 명령내리고 ui단이 control단에게 요청하고 그러다가 db나 파일처리를 해야한다면 PERSistency에게 시킨다. 그 뒤에 db가 숨어있을 것 : 3 layer

사용자는 바로 비지니스, persistent에 바로 갈 수 없고 ui도 persistent에 못감

→ 이렇게 해야 유지보수가 쉬움. Persistent에 접근하지 않고 바로 db가 가면 db가 바뀌면 buisinness가 영향을 받게 됨. 디비만 바뀌면 업무로직은 안바뀌게 됨. Ui가 바뀌면 액터만 영향받도록

cf. **MVC**(model view control, db에서 실체는 있는데 view가 있어서 실체를 가려줌, model은 persistent/entity, view는 바운더리, Control은 제어, mvc architecture)이라고도 한다

결과적으로 연관있는 것끼리 조직화하면 패키지가 되고 패키지를 클릭하면 클래스 다이어그램이 구성되어있음.

- 정적인 구조만 볼 수 있고 동적인 구조를 보려면 유스케이스 실현 모델이라는 시퀀스 모델을 만들어야 한다. 유스케이스 명세서를 보고 실현모델을 만듦

## 분석 유스케이스 실현 모델

- 유스케이스/이벤트흐름 별 실현 모델의 작성

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%208.png)

- 기본 흐름을 나타내는 시퀀스, 대안흐름을 나타내는 시퀀스 다 그리는데 너무 많으면 중요한 것만 그리면 됨
- 시퀀스를 그리게 되면 클래스도 찾을 수 있고 클래스가 가져야하는 기능도 찾을 수 있음, 한번에 만들지 못하니까 왔다갔다하면서 보충하는 것

ex) 소장도서검색 유스케이스 실현 모델

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%209.png)

액터가 바운더리 클래스에서 검색으로 가면 얘가 컨트롤 클래스,비지니스 클래스에게 검색을 요청하면 도서라는 엔티티 클래스에게 찾으라고 함. 점선이 생략되어있으므로 다 결과가 리턴될 것.도서 검색결과화면에서 화면을 만들고 루프를 돌면서 도서정보항목이라는 바운더리 화면을 여러개 만듦

유저는 바운더리, 바운더리는 컨트롤, 컨트롤은 엔티티한테 요청

- 설계에서는 액터가 사라지고 기술이나 기법에 따라서 클래스가 엄청 많아질 것
    
    도서검색화면 하나가 수백개의 클래스가 될 수 있음. Spring이나 cvd 기술을 쓰면 화면처리만 해주는 mvc가 들어가게 됨. 마찬가지 컨트롤도 설계단계로 넘어가면 이게 여러개의 클래스로 쪼개지게 될 것, 엔티티도 마찬가지로 디비 테이블 하나에 해당되는 경우도 있고 일처리해주는 다오 클래스도 있고 등등…
    
    여기는 도메인에 해당된 개념만 표현된 것
    

유스케이스를 실현하였고 이걸 유스케이스 명세서를 보고 그린 것이므로 명세서 작성이 잘 되어있어야 한다

**분석 모델의 요건**

- 분석클래스와 유스케이스 실현모델은 일관성이 있어야 한다.

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2010.png)

### 설계단계와의 차이점

- **응용 소프트웨어계층**만을 대상으로 여김
    
    분석은 도메인 계층만 생각하고 플랫폼, 구현 기술을 생각하지 않음. 실제 기술이 선택되면 엄청나게 클래스가 많아진다.
    
    ![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2011.png)
    
- 분석은 기능적 요구사항만을 고려하여 수행

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2012.png)

분석은 기능적 요구사항만을 고려하여 수행되고 명세서를 보면 기능적 , 비기능적 요구사항 둘 다 나오는데 기능만 고려해서 분석모델을 나오고 설계단계에서는 클래스가 많이 나올 것이고 관련있는 거끼리 묶으면 컴포넌트가 나올 것

-비기능적 요구사항은 설계단계에서하는데이걸 지원하기 위해서 기술이 필요할 것. 주로 하드웨어 아키텍쳐 설계를 이용하여 설계단계에서 비기능적 요구를 만족시킴

### 분석 단계 산출물

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2013.png)

분석이 끝나면 클래스, 시퀀스 다이어그램이 나오지만 필요에 의해 다른 다이어그램이 나올 수 있음. 하지만 최소는 이 두개, 이걸로 분석 명세서를 만든다.

- 분석 명세서에 클래스 모델과 유스케이스실현모델이 들어가 있음

## 분석 단계의 구성활동

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2014.png)

분석은 보통 분석 클래스 모델을 만드는데 완성이 안되므로 시퀀스도 같이 그려보면서 왔다갔다하면서 완성시키고 클래스가 완성되면 관련있는 클래스끼리 묶어서 패키지로 조직화

## 1. 분석 클래스 모델의 작성

- 각 유스케이스에 대한 명세서를 바탕으로 분석 수준의 클래스 모델을 작성하는 것을 목표로 한다

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2015.png)

유스케이스 명세서의 흐름이 엄청 잘 중요하고 이것을 바탕으로 분석 클래스 모델을 만든다.

- 분석 클래스 모델은 경계 클래스, 제어 클래스, 엔티티 클래스를 포함
- 분석 클래스 간의 연관관계(포함,집합), 일반화 관계, 의존관계를 포함
- 그러나 클래스 별로의 속성과 연산은 정의되어있지 않은 상태

경계클래스 -> 컨트롤 클래스 -> 엔티티 클래스 연관관계가 존재

ex)

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2016.png)

## 2. 분석 클래스의 상세화

- 분석 클래스 모델을 바탕으로 각 분석 클래스의 속성과 연산을 정의
- 각 유스케이스 별로 실현모델을 작성

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2017.png)

분석 클래스 다이어그램이 나오면 명세서를 가지고 시퀀스를 그리면서 속성, 함수들을 찾아냄

ex) 소장자료 검색유스케이스는 도서검색을 사용자가 누르고 화면이 생성하고 화면을 생성하기 위해서 도서에 대한 정보를 읽어와야 하고 검색은 컨트롤한테 시킨 것이고 일은 엔티티한테 시켰을 것…

→ 시퀀스를 그려야 메소드를 다 찾을 수 있음

흐름, 명세서의 흐름을 보면서 시퀀스를 그리고 이걸 보고 클래스를 채워나감

## 3. 분석 클래스 모델의 조직화

- 많은 수의 분석 클래스를 효율적으로 관리하기 위하여 패키지를 이용하여 분석 클래스들을 적절하게 배치

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2018.png)

다 만들면 많은 수의 클래스가 생기므로 패키지로 묶는다

개념적 유사성, 기능적 유사성, 변화의 유사성, 관리의 유사성으로 패키지를 묶는다

레이어를 형성

사용자가 로그인 버튼을 누르고 암호와 아이디를 주면 사용자라는 엔티티한테 로그인 정보를 받아오고 등등…

바운더리 클래스에는 머가 있는지, 컨트롤, 엔티티 클래스가 머가 있는지.. 시퀀스와 일관성있게 그려나가는 것

바운더리 하나가 설계단계에서는 화면으로 될 것, 자바에서는 프레임이 되고 웹에서는 세션이 될 것

### 모델 간의 일관성

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2019.png)

- 유스케이스 명세서와 유스케이스 다이어그램으로 분석하고 분석 클래스와 유스케이스 실현모델이 나오고 이 사이의 일관성도 있어야하고 클래스와 시퀀스 사이에서의 인관성도 필요
- 유스케이스 별로 유스케이스 실현모델이 정의되어있어야 한다

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2020.png)

- 유스케이스와 관련된 모든 액터가 유스케이스 실현 모델에서 사용되어야 한다

![Untitled](9-1%20Analysis%20Modeling%20127d6b1ae6044d3c91d8ca5e26b9cd41/Untitled%2021.png)

설계단계에서는 액터가 사라질 것

분석단계에선는 유스케이스에 액터가 있다면 시퀀스에 액터가 다 들어있어야 한다

- 분석 클래스 모델과 분석 유스 케이스 실현 모델이 일관성을 가져야 한다
    - 클래스/객체 일관성 규칙
    - 연산/메시지 일관성 규칙
    - 연관(의존)관계/메시지 일관성 규칙