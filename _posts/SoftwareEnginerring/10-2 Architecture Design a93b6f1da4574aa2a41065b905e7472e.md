# 10-2. Architecture Design

오늘부터 설계를 하는 건데 지난시간까지는 분석

오늘은 아키텍처 설계하고 다음주부터는 설계원칙하고 디자인 패턴 해볼 것

소프트웨어공학은 개발프로세스도 지원 품질보중 프로젝트 관리도 해야하는데 가장 중요한 것이 프로세스

첫단계는 요구사항분석이고 이 걸 두가지로 쪼개서 요구사항과 분석으로 봄 오늘은 설계를 볼 것

# 소프트웨어 설계

- **분석단계**
    - 분석단계와 비교할 때 사용자의 요구사항을 토대로 무엇을 사용자가 원하는 것이 무엇인지(what)를 찾는 것이므로 도메인 관점이 들어감. 구현의 관점은 들어가면 안된다. 주로 기능을 고려
- 설계단계
    - 분석 단계에서 파악한 기능과 비기능적 요구 사항 고려
    - 플랫폼 결정, how 어떻게 관점
    - 설계단계에서는 기능,비기능 모두 고려함. 분석은 주로 기능만 고려.
        
        비기능적 요구라는 것은 성능, 품질, 호환성을 의미
        
    
    → 이것을 맞춰줄려면 기술이 적용되어야한다. -> 플랫폼을 결정하고 어떤 구현기술을 쓸 것인지 결정
    
    분석에서 구한 What을 어떻게 구현할 것인지 how에 초점을 둔다
    

**설계**

- 설계는 요구분석 명세서를 기반으로 어떻게 구축할 것인지 결정한다.
- 설계자는 사용자가 원하는 비기능적 요구사항, 요구적 요구사항, 제약사항을 만족하는 대안이 많기 떄문에 대안 중 기간과 돈에 맞춰서 최적의 설계안을 찾는게 중요

Ex) 객체지향을 써야 한다면 자바도 있고 c++도 가능→ 방법 여러개 중에서 최적의 대안을 찾는 것을 말함

# 설계 종류

## 소프트웨어 아키텍처 설계

- 전체 시스템을 이루는 서브시스템 또는 모듈이 무엇이며 서브시스템 사이의 관계를 파악하는 작업

제일 큰 설계로 전체 시스템을 이루는 모듈, 관계가 무엇인지

Ex) 3층집을 지을고 하는데 당신이 원하는 것이 몇층이고 3층!

1층에는 로비가 있고 2층에는 머가 있고 방사이를 멀로 연결하고 층간은 어떻게 연결하는지

전체적인 구조를 찾아내는 작업임, 큰 구조, 큰 덩어리를 설계

## 인터페이스 설계

- 서브시스템들 사이의 인터페이스를 설계하고 정의하는 작업

서브시스템이나 모듈이 나올텐데 서브시스템 사이의 구체적인 인터페이스를 설계하고 정의하는 직업

Ex) 1층과 2층 사이의 계단을 어떻게 설계할 것인지

구체적인 방법들을 의미

## 자료 저장소 설계

- 파일이나 데이터베이스를 설계하는 작업

Persistency영속성 처리를 위해 파일이나 디비를 설계

## 모듈 설계

- 시스템의 컴포넌트가 되는 모듈, 즉 프로그램의 알골지므에 대한 설계 작업

서브 시스템을 실제로 구현하는 것

ex) 각 방을 구체적으로 꾸미는 것을 의미, 1번은 큰 덩이리가 어떻게 구성도고  그 간의 관계를 의미하고 모듈설계는 그 안을 설계하는 것을 의미

## 사용자 인터페이스 설계

- 메뉴나 입력 양식, 출력 화면 및 인쇄물을 설계하는 작업

화면, 입출력 방식 , 메뉴를 설계하는 작업을 의미

# 소프트웨어 아키텍처 정의

요즘은 아키텍처 설게 없이 실행하지 않음

- 프로그램/ 시스템의 컴포넌트들이 갖는 구조, 그들의 관계 그리고 그들의 설계와 시간이 흐르면서 발생하는 진화를 지배하는 원칙과 가이드라인

개발하려는 시스템의 컴포넌트, 서브시스템들이 갖는 구조, 부품들이 어떻게 구성되어있고 그들사이의 관계를 의미

설계와 구현까지 가는 원칙과 가이드라인임

코딩 시 아키텍트가 가면 문서들을 준다. 개발하려는 시스템이 어떻고 그들간의 관계를 알려준다

Ex) 함수는 소문자로 시작하고 camel 양식을 지켜야해, 클래스 이름은 어떤 식으로 해야해, 등등의 코딩의 명명규칙과 문서 작성 시의 규칙 등을 결정

규칙을 다 포함한 것이 소프트웨어 아키텍처, 설계 구현의 전체 구조를 의미

설계하고 코딩하는 전체과정에서 발생하는 규칙을 원칙과 가이드라인이라고 한다. 설계 구현의 전체 기준이 된다.

설계, 구현하려는 것들의 구성이 어떻게 되어있고 관계가 어떻게 되어있고 구현하기 위해서는 어떤 양식을 지켜야 하는지 등의 전체 틀을 잡아주는 것을 의미

- 개발할 소프트웨어에 대한 전체적인 구조를 다룬다
- 소프트웨어를 이루고 있는 여러 구성요소(서브 시스템, 컴포넌트)를 다룬다

구조를 다루고 서브시스템, 컴포넌트들을 다루고 그 구성요소가 어떻게 상호작하는지 본다

- 세부내용 보다는 중요한 부분만을 다룬다
- 시스템 설계와 개발 시 적용되는 원칙과 지침이 있어야 한다

→ 전체 설계 구현의 가이드라인, 기준의 된다

# 컴포넌트/모듈

### 컴포넌트

- 컴포넌트란 명백한 역할을 가지고 있으며 독립적으로 존재할 수 있는 시스템의 부분, 같은 기능을 가진 컴포넌트로 대체 가능
- 소프트웨어를 하드웨어처럼 만들어보자에서 소공이 시작, 부품이 고장나면 다른 부품으로 교체하면 되니까! C는 컴포넌트 단위가 함수, 자바는 클래스, cvd는 컴포넌트가 됨. 교체가능한 단위를 컴포넌트라 한다

### 모듈

같은 개념이지만 구현에 특화되어서 사용함. 구체적인 컴포넌트를 의미

- 모듈이란 프로그래밍 언어의 문법 구조에서 정의된 컴포넌트를 말한다

ex) 자바 프로그램의 모듈은 메소드, 클래스, 패키지가 된다. 교체 가능

C프로그램에서는 파일이나 함수를 의미

→ 추상적이고 개념적인 것은 컴포넌트이고 언어에 들어갈 경우에는 모듈이라고 함, 같은 말임

# 아키텍처 기반 개발의 장점

- 나온지 10년밖에 안되었지만 다들 아키텍처 기반으로 개발

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled.png)

**1)즉흥적인 개발**

요구사항이 나오면 바로 구현하는 방법  즉흥적인 개발, 중간에 요구를 바뀌는 경우 다시 코딩하는 것이 낫다

**2) 전통적인 설계 방법론을 사용한 개발**

설계 기반으로 하자. 바로 코딩하지 말고 설계를 한번하고 구현하자.집 지을 떄 설계 먼저 하니까 소프트웨어도 설계 먼저 한 후 구현하자!

**3) 아키텍처 기반의 개발 방법론**

제일 많이 사용하는게 아키텍처 기반 개발 

3-1) 아키텍처 

상세설계하기 전에 아키텍처를 만들자. 얘는 개발하려고 하는 전체 시스템의 구성과 관계가 어떻게 되어있고 나머지 설계 구현 시 지켜야하는 가이드라인을 결정, 전체에 대한 기준을 먼저 잡아놓고 그 다음에 상세적으로 설계

Ex) 롯데타워의 전체 틀을 잡고 각 층에 대한 내용은 나중에 설계

기능적인 상황도 보지만 주로 비기능적 요구사항(품질)을 만족하게끔 아키텍처를 설계함

3-2) 상세설계

아키텍처 가이드라인에 맞춰서 상세설계를 하게 되면 기능, 비기능적 요구사항도 지켜지게 된다. 원칙과 가이드도 지켜짐. 안되면 백한다

3-3) 설계

설계 시 그냥 구현하는 것이 아니라 이미 전체 구현된 전체 아키텍처 기반해서 상세설계 기반으로 하지만 전체 규칙에 맞게 구현

- 두번째 방법 보다 전체 가이드가 있었으니까 더 탄탄함. 처음부터 큰 틀을 잘잡았기에 상세적으로 설계해도 문제가 없게 된다

Ex) 큰 집을 지을 때에도 아키텍처 설계를 하니까 소프트웨어도 전체 아키텍처를 만들어놓자

# 아키텍처 기반 개발의 장점

- 아키텍처가 품질 요구사항 충족을 핵심적인 관심사로 보는데 비하여 전통적인 설계 방법은 기능 요구사항 충족에 초점을 둔다

아키텍처는 전체 어떻게 구성되고 관계가 어떻게 되며 지켜야할 가이드가 어떤 건지인데 아키텍처는 품질 요구사항 충족이 기본임, 요구사항분석까지는 기능적 요구가 중점이지만 아키텍처설계부터 비기능적 요구사항과 제약사항을 만족하기 위해 품질 요구사항을 고려 (전통적인 방법은 기능요구사항에 집중-> 나중에 기능은 돌아가지만 전체 시스템은 안돌아가는 경우 존재), 아키텍처는 큰 틀을 먼저 만들어서 안전하게 품질을 만들 수 있다

- 아키텍처 설계에서는 요구되는 다양한 품질 충족에 주된 관심을 두고, 이 과정에서 이들간의 상충관계를분석하고 서로 다른 대안 아키텍처 전략들 중 선택하게 된다.

품질을 만족시키는 여러 방법이 존재하는데 최적의 전략을 선택하기에 훨씬 안전한 편

Ex)객체지향 – 여러 대안이 있는데 아키텍처를 여러개 만들어보고 우리의 환경에서 머가 제일 좋은지 전략을 선택, 여러번 해보고 최적의 아키텍처를 선택

- 아키텍처 설계는 시스템을 구성하는 컴포넌트들의 식별과 이들을 연결하는 커 넥터들의 구성에 초점을 두며, 설계 절차가 하향식, 재귀적으로 진행되어 시스 템은 컴포넌트로 분해되고, 다시 이 컴포넌트들은 더 작은 컴포넌트들로 분해될 수 있다.

Ex) 1층엔 머, 2층에는 뭐 등등 큰덩어리를 먼저 설게한 후 한 층에 방 수를 정하고 각 방을 디자인 하는 식의  하향식,재귀식으로 진행

- 아키텍처 설계는 궁극적으로 요구사항 분석 활동으로 얻어진 요구사항을 모두 충족시킬 수 있는 시스템이 만들어 질 수 있도록 하기 위한 설계활동으로서, 설 계 및 구현을 위한 구조적 및 비구조적 틀(설계, 구현을 위한 가이드라인과 결정 들)을 제공한다.

궁극적으로 요구사항을 모두 만족할 수 있는. 기능, 비기능적 요구 등등을 모두 만족하는 컴포넌트의 구성과 관계, 가이드라인을 뽑아냄

# 아키텍처 스타일

: 전체 소프트웨어의 구성을 미리 어떤 스타일을 만들어놓은 것

Ex) 설계에 비잔티움 스타일 그리스 스타일 등 다양한 스타일이 있는데 아티스트 이름을 대면 아 이럼…이런 느낌하는 것처럼 소프트웨어도 스타일이 존재

## 1)client-server모델

- 네트워크를 이용하는 분산 시스템 형태
- 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용
- 분산 아키텍처에 유용
    - 서버 : 클라이언트에게 서비스를 제공
    - 클라이언트 : 서버가 제공하는 서비스를 요청(호출)하는 서브시스템
    
    ![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%201.png)
    

서비스를 제공해주면 서버가 되고 서비스를 제공받으면 클라이언트가 된다. Cs이전에는 서버하나에 여러 클라이언트가 달라붙어 있었다면 파일 제공해주는 파일 서버, 프린트 기능을 제공하는 프린터 서버 등등 서버가 서비스를 제공해주면 필요한 클라이언트가 네트워크를 통해서 사용, 제공과 사용의 역할을 나눠서 제공

기본적인 스타일

# 2) layered 스타일

레이어를 3개 이상, 매우 많이 나눠놓음

- 기능을 몇 개의 계층으로 나누어 배치
- 하위계층은 서버, 상위계층은 클라이언트 역할

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%202.png)

보통 맨 밑에 persistency(영속성)를 처리할 수 있는 부분이 존재하고 가운데는 로직처리(일처리)해주는 부분, 맨 위는 사용자 인터페이스가 주로 존재

이런식으로 해주면 각각의 레이어는 자신의 일만 해줄 수 있고 다른 레이어의 역할이 필요하다면 달라고 요청 가능

레이어가 엄청 나뉠 수 있으며 레이어는 논리적인 관점에서 쓰고 물리적인 관점에서는 티어라고 한다

cf. 3 layer tier(layer)

# 3) MVC 스타일

- model/view/controller 모델
- 중앙 데이터 구조
- 같은 모델의 서브시스템에 대하여 여러 뷰 서브 시스템을 필요로하는 시스템에 적합
- 세개의 서브시스템으로 분류하는 이유 : 변경에 대한 영향을 덜 미치도록 하기 위해, UI 부분이 자주 변경되더라도 모델 서브 시스템에는 영향을 주지 않기 위하여

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%203.png)

Layer와 비슷한 개념, 모델이 있어서 데이터와 데이터를 처리하는 로직을 모두 가지고 있음, 중앙에 디비와 로직이 같이 있지만 자기가 접근하고 싶은 테이블만 보는 게 view(presentation layer)

사용자 a가 뷰를 통해서 들어오면뷰에 정보가 보이기 위해서는 model layer에 접근해야하고 사용자를 위해서 뷰와 모델을 연결해주는게 컨트롤러

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%204.png)

모델에는 데이터와 로직처리가 같이 있고 view는 presentation이고 controller는 뷰와 모델을 연결,제어

cf. model은 영속성, view는 presenttion, c는 로직처리라고 하지만 원래는 model이 데이터와 로직을 가지고 있고 view는 보여주는 역할을 하며 controller는 연결하는 역할임

(장점)

- 관심의 분리

중간에 바뀌었을 때 다른 애가 영향을 덜받는다

로직 처리는 컨트롤러만 하면 되고 영속성 처리는 모델이 하면 된다

- 데이터를 화면에 표현한 뷰와 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능
- 구조변경 요청시 수정 용이

(장점)

- 기본 기능 설계로 인한 클래스의 수 증가로 복잡도 증가
- 속도가 중요한 프로젝트에 부적합

→아키텍처 스타일은 이거 외에도 정말 많으며 아키텍처 스타일을 들으면 어떤 느낌인지 파악 가능

# 아키텍처 설계 사례

아키텍처 설계에 명세서, 유스케이스 모두 다 들어감

A.시스템 개요

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%205.png)

B. 시스템 요구사항

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%206.png)

B. 1 기능 요구사항

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%207.png)

B.2 품질 요구사항(비기능적 요구사항)

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%208.png)

요구사항을 봤더니 비기능적 요구사항에는 여러 개가 있는데 품질, 성능, 사용용이성(ui가쉬워서 누구나 할 수 있도록 한다) 사서도 그냥 30분 이내에 모든 기능을 할 수 있도록 해야한다.

우선순위는 아키텍처가 분석해서 판단

B.3 제약사항(고객이 원하는 제약사항)

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%209.png)

어떤 경우에는 언어를 정해주기도 한다

⇒ 아키텍처를 설계할 것인데 기능과 비기능(품질)도 다 만족시켜야하고 제약사항도 만족시켜야하는데 아키텍처는 주로 품질과 제약에 초점을 둔다

C. 아키텍처 문제 분석

설계 전에 문제를 분석 

C.1 선정된 아키텍처 드라이버(구동하는 애, 하게끔 하는 애, 아키텍처를 만들기 위해서 중요한 애들)

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2010.png)

우리가 만들려는 아키텍처를 구동하는 드라이버, 아키텍처를 만들 수 있도록 하는 드라이버를 찾는다

중요성도 높고 난이도가 높은게 일차적으로 구현해야하는 것이므로 이걸 찾는다, 이건 아키텍트가 결정하고 고객과 얘기해서 결정

→ 이 다섯가지를 만족시키는 대안을 만들어야 한다

C.2 아키텍처 문제 분석표

만족시키는 전략은 매우 많고 그 중에서  선택

문제분석표- 설계전략과 이유를 작성

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2011.png)

⇒ 품질, 제약사항을 찾고 그중에 중요한 것을 드라이버로 선정해서 그걸 만족시키는 설계전략을 찾고 그게 반영이 되도록 설계해야한다

D. 아키텍처 설계 절차

D.1 아키텍처 스타일

- 아키텍처 스타일 선정 : CS 아키텍처 스타일 선정

D.2 아키텍처 관점 체계

아키텍처는 전체 디자인을 짜는 것이기 때문에 한 관점에서 볼 수 없음. 설계 도면이 하나만 있는게 아닌 것 처럼 앞에서 보는 거 뒤에서 보는 거 등등 설계하는게 다 다르므로 아키텍처 설계 시 덩어리를 여러관점에서 보고 그걸 뷰라고 한다. 이걸 여러개 찾는다

아키텍처 설계에서는 무조건 뷰가 나온다,여러가지 뷰로 본다

**1)시나리오 뷰**

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2012.png)

유스케이스 다이어그램정도를 의미

크게 시나리오를 그려서 어떻게 흘러가는지 보여줌

아주 중요한  흐름들을 보여줌

**2)논리뷰**

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2013.png)

전체적으로 어떻게 구성되어있는지 표현

위의 세개를 만족하기 위해 4개의 컴포넌트 사용

- 시나리오뷰에서 논리뷰로의 매핑

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2014.png)

시나리오뷰에 있던 c,s가 쪼개진다

Orb는 클라이언트에서 원격지에 있는 객체로 호출해주는 것,클라이언트가 서버에 접근하고 싶으면 반드시 Orb를 거쳐서 가야 한다

**3)모듈뷰**

- 시스템을 계층화한다
    
    ![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2015.png)
    

레이어 두개를 쪼개서 미들웨어에는 orb,db를 두고 어플리페이션에는 두개가 있고 그 사이에는 인터페이스가 있을 것, 클라이언트는 인터페이스를 타고 구현할 것, 클라이언트가 서버를 찾을 때에는 orb를 이용하고 이를 계층화하기에 밑에처럼 계층화한다

- 논리뷰에서 모듈뷰로의 매핑

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2016.png)

논리뷰에서는 컴포넌트이고 모듈뷰에서는 구현에 더 가까워졌기 때문에 모듈이 된다

소프트웨어 아키텍처는 큰덩어리와 연결하는 것을 찾는 것이기 떄문에 컴포넌트(orb,db 등등)와 이걸 연결하는 ilibrary같은 인터페이스를 구현

찾아낸 인터페이스를 기술 → 기능 요구사항을 만족

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2017.png)

인터페이스가 제공하는 함수의 이름과 소개, 실제 구체적인 설계는 상세설계에서 함, 시그니처 찾는게 아키텍처 설계임

- 인터페이스는 약속된 기능이 있는 메소드들이 있고 이는 서버가 구현할 것, mserverimpl은 엄청 많은 클래스들이 많을 것, 컴포넌트 안에는 여러개의 클래스가 존재, 아키텍처 설계에서는 윗단계를 본 것

**4) 실행뷰**

실제로 어떤 식으로 노드가 설치될 것인지

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2018.png)

Orb server processor는 100개까지 쓰레드를 만들도록, 클라이언트가 orb를 거쳐야 server에 들어갈 수 있으니까

원격지에 있으니까 rpc로 처리

**5)실행요소 배치뷰**

어떻게 배치시킬 것인가

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2019.png)

실행될 떄 프로세스 단위, 물리적인 노드 상에 올리 때 서버에 dbms를 같이 올리고 orb server도 같이 올리고 한대의 server에 100대까지 올 수 있다

- 모듈뷰에서 실행뷰로의 매핑

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2020.png)

모듈뷰에서 나왔던 것이 프로세스로 매칭이 되어야한다

**6)코드뷰**

- 소스코드 코드뷰

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2021.png)

어플리케이션이 나올 것인데 여기에는 libraryapp이 있고 앱을 서버 쪽에서도 호출해서 쓰고 여기서도 호출해서 사용, 기술이 적용된 것

- 코드 조직도

소스코드 조직도로 서버단과 클라이언트단에 어떤 파일이 필요한지

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2022.png)

- 실행뷰에서 코드뷰로의 매핑

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2023.png)

- 바이트 코드 코드뷰

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2024.png)

c++은 exe파일형태일 것, 바이트 코드로 나오게 된다

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2025.png)

- 이걸 묶어서 자르 파일로 나온다

**7) 코드 배치뷰**

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2026.png)

결국은 자르 파일만 올라가게 된다

여기에 원칙과 가이드가 같이 나온 것

얘는 사실 한번한거고 여러번 한 것, 추상화단계에서 하다가 점점 구체적인 단계 두단계로 이루어져있는데 여기는 한단계로 표현한 것

아키텍처 드라이버를 찾아서 설계전략을 이렇게 찾고 그거에 맞춰서 설계함 : 이게 하나의 안임

→ 아키텍처를 분석하고 평가해서 괜찮으면 이걸 쓰고 적합하지 않다면 다른 방법을 고를 수도 있음

: 그 중에서 최적으로 좋은 것을 선택함

→ 중요한 전체 틀이 나오므로 이걸 바탕으로 상세설계를 하면 전체가 구체적으로 나오진 않지만 중요한 것만 나온 것임. 이걸 위주로 설게해나감: 아키텍처 설계

# 아키텍처 구축 절차

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2027.png)

아키텍처는 요구사항을 찾아내서(품질, 비기능적 요구사항) 그 중에서 아키텍처 드라이버를 선택하고 만족하는 설계전략을 찾아내고 이를 만족시키기위해서 설계를 함. 

- 요구사항 분석
    - 요구사항 분석 단계와 동일
    - 품질 속성, 제약사항과 같은 비기능적인 요구사항에 더 많은 관심을 둠
- 아키텍처 분석

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2028.png)

- 아키텍처 설계
    - 관점 정의(뷰) : 관점은 뷰로 두고 여러 관점으로 개발
        
        시스템을 보는 방향에 따라서 이해되는데 다르기 때문
        
        이해당사자들사이별 관점이 모두 다르기 때문에 이해관계자를 파악하고 이해관계자별 관점을 정의
        
        ex) 개발자는 구현이 가장 중요하고 시스템 관리자는 프로세스가 중요, 노드를 어떻게 올리 것인지
        
    - 아키텍처 스타일 선택 : 여러 스타일 혼용 적용 가능
    - 후보 아키텍처 도출 : 관점별 다이어그램 작성, 아키텍처는 또한 여러개를 만들어서 하나를 결정, 아키텍처 명세서 기술
- 검증 및 승인

## 아키텍처의 4+1관점

여러가지 관점에서 시스템을 봐야한다

![Untitled](10-2%20Architecture%20Design%20a93b6f1da4574aa2a41065b905e7472e/Untitled%2029.png)

가운데 유스케이스가 가장 중요하고 그걸 분석이나 설계자 입장에서는 클래스가 먼지 컴포넌트가 먼지 논리적인 관계가 중요, 프로그래머 입장에서는 어떻게 구현할 것인지 모듈 뷰, 구현뷰 같은거, 통합자는 프로세스뷰, 시스템 에지니어는 노드에 어떻게 배치되는 지 deployment 다이어그램

네가지 관점은 가운데에 있는 기능을 만족하기 위함임

(정리)

이런식으로 하는게 아키텍처 설계임

이게 끝나면 각각의 서브시스템별로 팀이 나뉘어져서 설계를 하고 그 안에 클래스가 머가 들어가는지 설계하고 코딩하고 이런 식으로 넘어가게 됨

아키텍처 설계 – 전체 시스템을 구성하는 큰 덩어리를 여러 관점에서 보는 것, 유스케이스 다이어그램, 클래스 다이어그램도 나오고 배치 다이어그램도 나오고 등등 여러 관점에서 시스템이 어떻게 작동되는지를 보여줌

이러한 여러가지 관점들은 사용자의 요구를 당연히 만족해야하고 비기능적 요구사항, 품질, 제약사항도 만족해야 한다

- 품질을 찾아내고 중요한 것을 드라이버로 선정한 후 드라이버를 만족하는 설계전략을 찾아내서 그걸 반영할 여러 뷰 관점에서 다이어그램 그림

→ 이러한 아키텍처 설계는 여러번 하고 최적의 설계를 하게 되고 팀으로 나뉘어져서 개발하게 됨 → 상세설계

아키텍처가 관점을 선택하고 그 관점에 맞게 다이어그램을 그리는데 얘는 설계전략을 만족하게끔 그린 것임. 그 설계전략들은 요구사항을 찾으면 품질,비기능, 제약사항을 찾아내고 그 중에서도 제일 중요한 것들을 찾아낸다. 찾아낸 이것들을 만족시키는 설계전략을 찾고 그걸로 아키텍처를 만듦. 이게 아키텍처 드라이버! 아키텍처를 만들게끔 하는 애들 품질 속성 중에서 아키텍처를 만들기에 중요한 애들을 아키텍처 드라이버라고 하고 이걸 아키텍처로 만듦