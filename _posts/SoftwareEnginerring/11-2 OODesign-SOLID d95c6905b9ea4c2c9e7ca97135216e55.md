# 11-2. OODesign-SOLID

# SOLID Principles

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled.png)

객체지향원리인 solid에 대해서 알아보자

5가지 객체지향설계원리를 나타내고 영어로 썼을 때 앞글자를 따서 만듦

- **단일 책임의 원칙(SRP)**

클래스는 여러개의 책임이 아닌 하나의 책임을 가져야 한다

- **OCP**

변화에는 닫혀있고(변화 시 덜 영향을 받아야한다) 객체지향 확장에는 쉽게 되어야 한다

확장에는 열려있고 변경에는 닫혀있다

- **대치 원칙(LSP)**

서브 클래스가 슈퍼 클래스를 완전히 대치할 수 있어야 한다. 서브클래스는 슈퍼클래스의 기능을 모두 대치해야 한다

- **인터페이스 분리 원칙(ISP)**

어떤 클래스를 사용하는 클라이언트에게 필요한 부분만 인터페이스만 보여줘야지 사용하지 않는 부분까지 보여주면 안된다

- **의존관리 역전의 원칙(DIP)**

추상화 또는 인터페이스를 사용, 구체적인 것에 의존하면 안되고 추상적인 것에 의존해야 한다

## 1. SRP(Single responsibility principle)

- 단일책임의 원칙
- 객체는 단 하나의 책임만을 가져야 한다
- 클래스를 변경하는 이유는 단 한개여야 한다

변경할 이유가 생긴다면 이유가 하나여야한다. 여러개라면 이 클래스는 여러 개의 책임을 가지고 있다는 것임

- 응집도를 향상시키는 원리, 하나의 일만 하니까
- 책임은 변경의 이유
    - 책임이 많으면 클래스는 여러가지 이유로 변경될 여지가 많으니까 좋지 않다.
    - 책임을 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다
    - 내부에서 서로 다른 이유 때문에 변경해야 하고 다른 클래스와의 결합도가 높아지는 것이고 이것은 수정하기 힘들게 된다

→ 클래스는 하나의 책임을 지는 것이 좋다

Ex)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%201.png)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%202.png)

처음에는 http 프로토콜로 데이터를 읽어와서 화면에 보여주는 기능

Display는 html을 읽어와서 읽어온 데이터를 data에 넣고 그걸 update함

Load html은 html에 접속해서 읽어온다 반환형은 string

updateGUI 시 매개변수는 string이고 이 전에 파싱을 먼저 처리 후에 바꾼다

→ 데이터를 읽어오고, 그 데이터를 가지고 화면을 개시하는 역할을 display가 이 두가지 행동을 함

여기서 프로토콜을 좀 바꿔야한다고 가정

socketClient라는 low level로 읽어올 것, 문자열을 받는게 아니라 좀 더 낮은 수준의 접근방법을 이용해서 바이트배열을 받는다 -> load html반환형 -> 리턴으로 data타입 변경 -> updateGui -> parse_ 타입 다 바뀜

읽어오는 부분을 바꾸니까 화면 갱신 부분도 바뀌게 됨. 하나의 책임을 바꾸니까 다른 책임에 관계된 코드도 같이 바뀌게 된다 : 단일 책임의 원칙에 위배!

→ 각각의 클래스가 하나의 역할만 하도록 해야 한다

### 책임을 분리하면 변경의 여파를 줄일 수 있다

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%203.png)

데이터 보여주는 클래스와 읽어오는 클래스를 사용. 그리고 데이터 타입 중에서 너무 하위수준의 데이터타입만 사용했으므로 추상화한 타입을 사용하도록 한다

역할을 나눠주고 의존하게 해서 하나의 역할만 가지도록 한다

### 책임이 분리되지 않을 경우

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%204.png)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%205.png)

우리의 코드를 사용하는 클라이언트가 있는데 우리는 읽어오는 역할만 하고 싶음. 이전처럼 설계될 경우에는 내가 만든 코드를 사용하는 클라이언트는 load만 하고 싶은데 쓸데없는 updateGUi기능도 가지게 되므로 필요없는 패키지도 가지게 되어 결합도가 높여져 한부분이 변경되면 영향을 많이 받게 된다

→ 클래스 분리한다면 각각의 필요한 패키지만 사용할 수 있으므로 더 좋다

### 책임이란 변화에 관한 것

- 클래스 사용자들이 서로 다른 메소드를 사용한다면 그들 메소드는 가각 다른 책임에 속할 가능성이 높고 따라서 책임 분리 후보가 될 수 있다

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%206.png)

클래스를 첨에는 화면에 보여주고 가져오는 것으로 만들었는데 사용하는 클래스가 gui는 disply만 dataprocessor는 load만 접근하게 된다.클라이언트들이 각각 다른 메소드를 사용한다면 분리되어야하는 책임이 아닌가 생각해야 한다!

## SRP 위반의 악취들

위반의 코드를 보다보면 크게 두가지임

**1) 여러 원인에 의한 변경** 

- 하나의 클래스가 있는데 책임이 여러개가 있어서 여러가지 원인에 의해서 고칠 필요가 있을 떄 발생
- 즉, 하나의 클래스에 여러 책임이 혼재하고 있어 하나의 책임의 변화가 다른 책임에게 영향을 줌

ex) 화면과 관련된 것에 의해서 변경이 되고 데이터를 불러오는 것 때문에 변경이 된다면 역할이 두개라는 것!

- 일반적인 예시

**2) 산탄총 수술**

원래는 클래스가 하나의 책임을 가져야하는데 그 책임이 분산되어있는 경우

- 어떤 변경이 있을 경우 여러 클래스를 수정해야 하는 증상

하나의 책임이 여러 클래스에 분산되어 여러 클래스가 바꾸는 경우

ex) 어떤 변경의 대상이 여러 곳에 분포되어 있어 마치 산탄총 총상 환자를 수술해야하는 것 같은 많은 노동 비용이 따르게 된다, 산탄총 수술이라고 함. 여러 군데 쓸대없는데까지 쏘는 것이라고 본다. 한군데만 수술하는 게 아니라 여러군데를 수술해야 한다

- 하나의 책임이 여러 클래스에 분산되어 있기 때문에 발생
    - 변경 이유 발생 시 변경할 곳이 많음
    - 변경될 곳을 빠짐없이 찾아 일관되게 변경해야 함

Ex)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%207.png)

비지니스 로직 a, b,c라는 함수가 있는데 보통 모든 어플리케이션에는 로깅 기능, 보안 서비스, 트랜잭션 서비스 기능이 있는데 그 기능을 하나하나 다 쪼개놓으면 로깅방법이 달라지면 계속 바꿔야 한다.

로깅을 남긴다던지 보안처리하는 것들은 모든 클래스에서 항상 다 일어나야 하는 기능, 

→ 즉, 산탄총 수술이 일어날 수 밖에 없는 기능

모든 일을 하기 전에는 로깅해야 하고 보안 처리도 해야하고 트랜젝션 서비스도 하나로 묶여야 한다 

-> 이런 처리는 기본적으로 산탄총으로 될 수 밖에 없다 -> **AOP,aspect oriented programming**을 사용 : 예전에는 기능을 뜯어놨는데 하나씩 클래스를 만들고 개만 책임을 지고 있고 계속 끼어들어야 하니까 중요한 업무 전에 모두 처리가 되어야하니까 클래스를 만들 뒤 코딩 시 넣지 않고 컴파일,런타입에 주입해서 코딩할 때에는 영향을 끼치지 않도록, 로깅방법이 바뀌면 그 클래스만 바꾸고 주입해주면 끝내는 방법

예전에는 동일한 코드를 다 넣었지만 지금은 AOP사용

산탄총이 나올 수 밖에 없는 기능 : 보안, 트랜젝션..

→ 너무 많은 책임을 가져도 문제이지만 하나의 책임을 여러 클래스에 뿌려 놓는 거 또한 책임이 있다!

⇒ 한 클래스가 너무 많은 책임을 맡고 있어도 곤란하지만 책임을 식별하지 못하여 이를 담당할 클래스를 만들지 않고 여러 클래스에 흩뿌려 놓은 것 또한 문제! (프로그램의 전체 책임을 올바르게 분담하지 못하여 발생)

## 2. OCP(Open-Cloused Principle)

- 개방폐쇄원칙
- 변경에는 닫혀있고 확장에는 열려있다
- 기존의 코들를 변경하지 않으면서(closed) 기능을 추가할(open) 수 있도록 설계가 되어야 함
    
    수정에는 영향을 덜 받아야하지만 확장은 쉽게 되어야한다.
    
    변경은 쉽게 되면 안되고 기능 추가는 쉬워야 한다
    

Ex) 

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%208.png)

클라이언트가 성적표에서 학생 data를 출력하거나 출석부에서 data를 출력할 수 있는데 또 다른 클래스를 만들게 되면 의존관계가 많아진다→ 학생이 바뀌게 되면 연관된 애들이 다 영향을 받으므로 변경에 닫혀있게 된다, 확장 시에도 영향을 받고 있음 : 변경하기는 쉽고 확장하기 어렵다

→ OCP를 만족하기 위해 다형성을 적용

변경하기 쉬운 부분을 캡슐화로 묶고 이를 추상화해서 부모클래스나 인터페이스로 abstract으로 만들어서 클라이언트는 변경가능한 것에 의존하는 것이 아니라 추상화한 인터페이스에 의존해야 한다, 바뀌어도 영향을 안받으며 새로운 것이 들어와도 영향을 덜받음

- 단순 is-a, 상속관계가 아니라 유지보수성에 대한 것
    - 자주 바뀌는 것은 캡슐화와 추상화의 조합으로 이루어짐
    - 부모클래스를 추상화하여 변경 못하게 한다
    - 자식 클래스에서 확장을 통해 변경(다형성)

Is a 관계가 아니여도 인터페이스로 만들고 외부에는 얘만 보이게 해고 변경되어도 영향을 덜 받게 한다

자주 바뀌는 것을 캡슐화하고  공통적인 것을 추상화해서 부모클래스로 만들어서 추상화해서 변경을 못하게 하고 자식클래스에서 확장

### OCP가 적용되는 경우

주로 다형성을 말함

- if-else블록이 존재하는 경우

Ex)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%209.png)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2010.png)

게임에는 draw라는 함수를 다 쓰고 추상화를 잘 시켜놓음

적이 그림을 그린다는 것은 움직일 때 패턴이 있어서 패턴을 세팅

패턴이 1이면 4로 이동, 2면 y로 이동 등 패턴에 따라서 그림을 그림 : ocp 가 안되는 경우, c같이 코딩

새로운 패턴이 들어오면 다시 코딩해야한다 : 변경에 열려있고 확장에 닫혀있음

→ If/else를 다형성에 대입해야 한다

적은 path pattern을 가지고 있고 x,y좌표를 바꾸는데 상속받아서 구체적인 것은 캠슐화하고 공통적인 것은 추상화해서 표현, 적은 Pathpattern이라는 추상적인 부모클래스만 알고 시키면 다형성이 적용되어서 알아서 적용될 것

적 입장에서 새로운 패턴이 들어오면 setter로 바뀌면 되고 얘는 바꾸지 않게 된다 : 변경에는 닫혀있고 확장에는 열려있다

## 3. LSP(Liskov subsitution principle)

기본적으로 다형성이나 upcasting 시 서브타입은 슈터클래스를 대체할 수 있다.(대체가능성)

대체했다고 생각하지만 사실 대체하지 않은 경우가 많이 존재

- 서브 타입은 언제나 기반 타입을 대체할 수 있어야 한다
    - 서브 타입은 기반 타입이 약속한 규약(public 인터페이스, 메소드가 던지는 예외도 포함)을 지켜야 한다
    
    서브타입은 슈퍼타입이 약속해놓은 규약,예외, 반환형을 반드시 지켜야 한다
    
    오버라이딩하는데 오버라이딩하더라도 substituion이 안된 경우가 많음
    
- LSP를 만족하면 프로그램에서 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변화 x, 프로그램은 정상적으로 동작

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2011.png)

LSP를 만족한다면 서브클래스가 부모클래스를 잘 대체했다는 것인데 슈퍼클래스에는 자식 클래스가 업케스팅되어서 잘 들어갈 것, 오버라이딩을 잘했다면 서브클래스를 넣어줘도 대체되지만 잘 되지 않은 경우가 존재

### LSP가 지켜지지 않을 떄의 문제

Ex) 

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2012.png)

사각형의 약속은 width는 width만 바꾸고 height는 height만 바꾸고 가져오는 것

우리는 정사각형을 만들 것이고 상속을 했는데 가로세로가 같으니까 오버라이딩 시 가로와 세로를 둘다 세팅하고 setheight도 width까지 세팅을 했음

→ 이렇게 설계가 된다면 사각형을 비교해서 hiehgt를 더 크게 설정한다. 가로 길이보다 세로를 10 크게 하겠다! 이 메소드를 보았을 때 무조건 사각형의 높이는 가로길이보다 길다고 생각하지만 실행하니까 같지 않을 경우도 존재함

만약에 square을 넣어주면 setheight 호출 시 가로세로 같게 되는데 클라이언트는 동일하다고 생각안함

문제 – 사각형을 만든 사람은 가로만 바뀌어 라고 생각했는데 상속받은 square은 가로만 바꿔야 하는데 세로도 바꾼 거임!

→ 즉, 서브클래스가 슈퍼 클래스의 역할을 대체하지 못함. 슈퍼는 가로만 바꾸는데 서브는 맘대로 가로 세로를 다 바꿈(LSP x)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2013.png)

정사각형일 때 안지켜지니까 square이면 예외를 던지고 square가 아니면 적용되도록 <- OCP가 안된거임

다른게 확장해도 사용하는 측에서 영향을 안받아야 하는데 하나하나 체크하게 되면 영향을 받을 수 밖에 없다.(if문)

새로운 게 추가되는데 squre처럼 규약을 안지키게 되면 계속 바뀌어야 한다 : OCP, 변경에 닫혀있지 않고 확장에 열려있지 않음

LSP가 안되면 OCP도 안됨

실세계에서는 상속관계인 것처럼 보이지만 규현시에는 아닐 수도 있다

→ lSP는 약속에 관한 내용, 이 기능은 이런일을 할 거야 약속, 기능, 규약이므로 서브클래스는 슈퍼클래스의 규약을 맞게끔 지켜줘야 한다

즉, setHeight는 매개변수로 높이만 바꾸고 폭은 바꾸지 않는다. 이약속을 꼭 지켜야 한다

### LSP를 어기는 흔한 예

- 상위 타입에서 지정한 리턴값의 범위에 해당하지 않는 값을 리턴하는 경우

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2014.png)

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2015.png)

return 타입을 지키지 않은 경우

입력할 수 있는 input stream에는 read라는 함수가 있는데 끝에 오면 -1을 리턴함

Copytil이라는 카피기능은 is,out을 받아서 입력받은 것을 출력에 복사. 데이터의 끝이라면 -1이므로 -1이 아니라면 잘 읽은 거니까 길이만큼 출력

이 inputstream을 상속받았는데 api를 보면 read 메소드는 더 이상 읽을 게 없으면 -1을 리턴해야한다라고 되어있지만 나는 데이터가 없으면 0을 리턴함→ 대체를 못하게 됨

Is, output에서 copyutil에 호출 되지만 여기에 badinputstream이 있는데 얘는 마지막이라고 -1이 아닌 0을 리턴해버리게 되므로 안끝나게 됨. 사용차는 측에서는 당황하게 된다

### LSP는 계약과 확장에 대한 것

- 기능의 명세,규약, 계약에 대한 내용

설계는 클래스나 함수 설계 시 하기로 한 것은 시그니처, 헤더부분에 나온다. 클래스도 마찬가지 시그니처에 나온다, 이 규약을 지켜야 한다

- LSP 위반 사례
    - 명시된 명세에서 벗어난 값을 리턴
    - 명시된 명세에서 벗어난 예외를 발생
    - 명시된 명세에서 벗어난 기능을 수행
- LSP는 확장에 대한 것이고 LSP를 어긴다면 OCP를 지킬 수 없음

대체가 안되면 또 if를 넣게 되므로 확장에는 닫혀있게 되므로 OCP도 적용이 안되는 것

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2016.png)

상속의 기본은 다형성이지만 확장효과를 얻기 위해서는 규약을 어겨서는 안된다.

서브는 슈퍼클래스가 해주기로 한 약속을 그대로 지켜야한다

LSP가 되어야 OCP가 된다. 즉, LSP(규약을 만족하는 상속구조)는 OCP(확장에 다형성 제공)를 구성하는 구조가 된다

## 4.ISP(Interface segregation principle)

- 인터페이스 분리의 원칙
- 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙
- 클라이언트 관점에서 클라이언트 자신이 이용하지 않는 기능에 영향을 받지 않아야 한다

어떤 클래스가 제공해주는 인터페이스는 그 클래스를 사용하는 클라이언트에게만 보여줘야 한다

Ex) 

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2017.png)

복합기는 세가지 기능을 하는데 이것을 사용하는 클라이언트는 프린터만 쓰면 프린트만 보여야 한다

자기가 필요로 하는 인터페이스만 보여야 한다

### SRP vs ISP

- 어떤 클래스가 단일 책임을 수행하지 않고 여러 책임을 수행하게 되면 방대한 메소드를 가진 비대한 클래스가 될 가능성이 커지며, 당연히 비대한 인터페이스가 제공된다.
- 이렇게 비대한 클래스를 SRP에 따라 단일 책임을 갖는 여러 클래스들로 분할하고 각자의 인터페이스를 제공한다면 ISP도 만족할 수 있다.
- SRP를 만족하더라도 ISP를 반드시 만족한다고는 할 수 없다.
    - 단일 책임을 제공하더라도 클라이언트에 따라 특정 인터페이스만 제공해야 할 수도 있다.
        
        하지만 SRP를 만족해도 ISP를 반드시 만족하다고는 할 수 없다. 단일책임해도 여러 함수가 있을 수 있고 클라이언트는 그중에서 일부 기능만 사용할 수 있음. 그래서 SRP를 만족해도 클라이언트가 일부만 사용한다면 일부만 사용하는 인터페이스를 제공해줘야 한다
        

## 5. DIP(Dependency inversion principle)

- 의존관계 역전의 원칙
- 의존관계를 맺을 떄 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 원칙
    
    인터페이스나 추상클래스는 변하지 않는 것, 구현한 클래스나 서브클래스는 변하기 쉬운 것임
    

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2018.png)

1. High level module(사용하는 클래스)는 low level module 사용 시 구체적인 것에 의존하는 것이 아니라 추상적인  것, 변하지 않는 것에 의존해야 한다
2. 추상적인 것은 세부적인 것에 의존하는 것이 아니라 세부적인 것이 추상적인 것에 의존해야 한다

⇒ 즉, 의존관계를 맺을 때에는 자주 변하는 것(concrete)한 거에 의존하지 말고 인터페이스나 추상클래스만 보여야 한다

Ex)적에서는 밑에 있는 두개의 클래스에 의존하지 않고 얘는 pathpattern이라는 추상클래스, 인터페이스에만 의존해야 하고 구체적인 클래스도 인터페이스에 의존해야 한다

Ex) cook에서 Korean cook,chinessecook처럼 구체적인 클래스에 의존하면 안된다. 인터페이스 icook에 의존해야 한다

ex) 구체적인 성적표 출석부에 의존하지 않고 printStudent 변하지 않는 것에 의존해야 한다

### 의존성 주입(dependency injection)

Ex) 

아이는 로봇이나 모형 자동차에 의존하지 않고 장난감이라는 추상적인 변하지않은 개념에 의존한다

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2019.png)

Kid는 토이에 의존한다. 토이에 의존하고 kid안에는 로봇 등 구체적인 클래스가  없다

DIP가 없다는 것은 toy = new 로봇();←이렇게 되면 구체적인 것에 의존하므로 OCP가 안된다.

→ DIP를 지키니까 OCP가 되는 것

구체적인 것은 setter나 클래스 밖에서 넣어줘야 한다

: 밖에서 주입해준다, 의존관계 역전, 의존성 주입

cf. 메인코드에서도 제거하고 쉽다면 스프링같은 것은 런타임으로 주입 가능

- DIP를 만족시키게 되면 어딘가에서 의존관계를 주입시켜줘야하는데 바로 넣어주는 것이 아니라 밖에서 주입해야 한다

(정리)

1) SRP, 단일책임 원칙

2) OCP, 변화에는 닫혀있고 확장에는 열려있다

3) LSP, 서브클래스가 슈퍼 클래스를 대체해야 한다

4) ISP, 인터페이스 분리의 원칙

5) DIP , 의존관계 역전, 변하지 않는 것에 의존

이것들은 변화에 유연하게 대처하는 설계원칙

![Untitled](11-2%20OODesign-SOLID%20d95c6905b9ea4c2c9e7ca97135216e55/Untitled%2020.png)

- SRP, ISP는 객체가 커지지 않도록 해준다

→ 객체가 많은 기능을 가지게 되면 영향을 주게 되고 SRP

]를 가지고 ISP를 가지게 한다면 영향을 최소화시켜서 결합도를 떨어뜨려 준다

- LSP(서브클래스는 슈퍼 클래스를 대체해야 한다, 다형성),DIP(변하지 않는 것에 의존, 추상화)는 OCP를 지원한다. 만족해야 OCP가 가능해진다

OCP의 기본은 다형성

- ISP는 클라이언트 입장에서 사용하는 부분만 보여주는 것이고 DIP도 구체적인 코드가 아닌 필요한 기능부분을 인터페이스로 만들어주는 것, LSP는 슈퍼클래스에서 공개한 api는 구현할 것을 약속

솔리드를 지켜야 변경에 영향을 덜받고 확장이 쉽게 될 수 있음