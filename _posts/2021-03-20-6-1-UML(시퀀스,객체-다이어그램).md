---
layout: post
title: 6-1. UML(시퀀스, 객체 다이어그램)
date: 2021-03-20 19:20:23 +0900
category: SoftwareEngineering
---
# 6-1. UML(시퀀스, 객체 다이어그램)

(복습) 

클래스 다이어그램

- 어떤 클래스가 있는지 관계가 어떻게 되는지 가장 중요한 다이어그램 중 하나
- 연관관계 (집합, 포함)
- 상속관계(추상클래스, 인터페이스 실체화)
- 의존관계(메소드 안에서 사용)

코드로 어떻게 나오는지 알면 된다

# 객체 다이어그램(Object diagram)

클래스 다이어그램은 객체가 아니라 구조를 보여주는 것이지만 실제로 특정 시점의 스냅샷을 보고 싶은 경우가 존재 : 딱 그 때의 시스템 상태, 객체로 구성되어 있으니까 객체 다이어그램을 사용

- 특정한 시간의 시스템의 전체 또는 부분 구조를 표현
- 특정한 객체 인스턴스의 집합과 속성값, 그리고 인스턴스 사이의 링크에 집중함
- 링크 : 클래스들 사이의 연관관계 인스턴스
- 클래스 다이어그램보다 더 구체적이며 일반적으로 클래스 다이어그램의 예를 제공하거나 테스트케이스로서의 역할을 함
    
    실시간 시스템에서 상태를 알고 싶을 경우에 많이 사용함. 테스트 케이스로 제공함
    

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled.png)

-실행하는 특정 시점에서의 좌표 3개의 현재 상태를 알려줄 수 있다.

 그리고 이 선은 연관관계가 아니라 링크라고 한다. 실시간으로 링크되어있다를 의미!

### 인스턴스

클래스로부터 클래스의 인스턴스가 생성됨

밑줄에 객체이름있으면 객체

### 링크(link)

링크는 연관관계의 인스턴스

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%201.png)

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%202.png)

속성만 보이고 메소드는 안보임

# 시퀀스 다이어그램

클래스 다음으로 주요한 다이어그램

-한글말로는 순차도(순서도와 구분,flow chart)

-대표적인 상호작용 다이어그램으로 클래스다이어그램은 객체가 아닌 클래스를 보는 것이며 객체는 실제로 일하는 대상으로 어떻게 상호작용하는지 등등을 표현

# 상호작용 다이어그램(interaction)

- 객체가 어떻게 상호작용하는가, 어떤 순서로 상호작용하는 가를 표현함
- 시스템의 행위를 표현
    - 구조가 아닌 행위, 동적인 측면을 표현한다
- 유형
    - 시퀀스 다이어그램(sequence diagram)
    - 커뮤니케이션 다이어그램(communication diagram)
    - 인터렉션 오버뷰 다이어그램(interaction overview diagram)
    - 타이밍 다이어그램(timing diagram)

## 시퀀스 다이어그램 vs 커뮤니케이션 다이어그램

- 유사한 정보를 다른 방식으로 표현함 : 동일한 정보이지만 관점이 다름

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%203.png)

- 시퀀스 다이어그램 ↔ 커뮤니케이션 다이어그램
    - 커뮤니케이션은 다루지 않으나 대부분의 모델링 도구에서 상호변환 기능 제공
    - 시퀀스와 커뮤니케이션 변한이 쉬워서 주로 시퀀스를 그린다. 커뮤니케이션은 객체나 클래스로 대체가 가능하기 때문
- 둘 다 상호작용과 객체 여러 개가 일하는 것을 표현한다.
    - 시퀀스는 시간 중심, 시간에 따라서 순서(흐름)대로 표현
    - 커뮤니케이션 다이어그램은 같은 거지만 클래스 다이어그램처럼 구조를 좀 더 봄. 메세지를 어떤 객체가 주고받는지 순서보다 구조에 더 관점을 둔다. 협력하는 것(colloboaration)

# 시퀀스 다이어그램

- 참여자 간의 시간적 순서에 따른 상호작용을 표현
    - 참여하는 객체들간의 시간적인 순서에 따라서 어떤 식으로 상호작용하는 것이 가장 중요하다
- 요구사항 정의 단계 : 유스케이스 시나리오 표현
- 분석단계 : 유스케이스 실현 표현(분석관점)
- 설계단계 : 유스크에이스 실현 표현(how관점, 플랫폼,기술을 써서), 인터페이스 실현 표현(ui를 어떻게 실현할 것인지)

분석단계에서는 유스케이스를 어떻게 실현할 것인지 분석 관점, 설계에서는 how, 플랫폼에서의 관점, 인터페이스를 어떻게 실현할 것인지에 즉, 모든단계에서 사용한다

클래스와 시퀀스는 모든 단계에서 사용한다는 점에서 매우 중요

- 클래스 다이어그램 - 구조적 측면
- 시퀀스 다이어글매 - 동적 측면

# 시퀀스 다이어그램 : 핵심 개념

### 생명선

- 상호작용에 참여하는 구체적인 대상을 표현
- 액터, 클래스의 객체, 컴포넌트의 인스턴스 등이 될 수 있음
    - 액터가 올 수 도 있고(시스템을 사용하는 사람 혹은 외부 시스템) 주로 왼쪽에 오는 편
        
         보통은 클래스의 객체 혹은 컴포넌트 인스턴스, 실제 대상들이 온다
        

ex) 네모(객체, 클래스의 객체)와 막대기 : 생명선

시퀀스 다이어그램은 객체가 선이 있는 동안 살아있어야 하며 객체와 생명선이 있어야 한다. 객체와의 상호작용을 보여준다

### 메시지

- 생면선 간에 전달되어 상대의 행위에 대한 호출

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%204.png)

Ex) 엘리베이터 동작을 표현

눌러서 컨트롤러에 1번 컨트롤러가 문 device interface한테 닫아 -> 그리고 1번 모터한테 위로 올라가! -> 2층에 도착하면 2층 센서가 감지해서 컨트롤러에게 알려줌 -> 엘리베이터가 2층보고 문 열어라고 한다

- 시퀀스 다이어그램은 하나의 상황/시나리오만을 표현
- 필요한 정보를 노트로 표현했었는데 소프트웨어가 방대해지게 되면서 우리가 할 수 있는 모든 걸 거의 다 할 수 있게 됨

### UML 2.0의 추가된 표현법

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%205.png)

Ex) 하나의 시나리오를 표현, 모든 객체들의 상호작용을 보여준다.

상호작용 이름을 좌상단에 표시한다.

보통은 엑터가 있어서 가는 편이지만 넘어가다 보면 처음부터 없는 경우가 없는 경우가 존재 이것 시작점을 까만 점으로 표현(전체 보면 알 수 있지만지금은 모를 수 있어서)

누군가가 버튼을 누름 -> 컨트롤러에게 층번호를 주면서 이동해! -> opt, 작은 상호작용을 의미, 상호작용 안에 상호작용이 있을 수 있다. Opt(optional)선택적으로 한다. 문이 열려 있으면 닫으라고 요청하고 닫혀있으면 안한다.

Loop는 반복하라는 의미 자기자신한테 메세지를 보낼 수 있다(자신의 메소드를 호출하는 것)

2번 : 문di에 있는 닫기 메소드를 호출하는 것

3번 : 자기자신이 가지고 있는 이동방향결정()을 호출

결정된 방향으로 4번 -> 모터한테 이동해라고 요청

여기까지가 엘리베이터의 이동 메소드가 해야하는 일

중간에 센서들이 있음. 엑터(우리가 개발할 분야 아님, 물리적인 하드웨어)가 층마다 존재해서 감지해서 도착센서한테 알려줌 -> 요청을 받아서 도착 interface는 컨트롤러에게 알려줌 -> 정지할건지 말건지 결정 : 참거짓이 나옴 -> 이걸 원하는 층만큼 해야하니까 loop!-> 여기서 optional로 이번층에 정지를 해야 하면 모터한테 멈추라고 하고 지금 운행 정보 객체를 생성한 후 외부로 보냄-> 서버에 저장될 것 그리고 병렬적으로 Par(parallel,병행적으로 돈다, 쓰레드로 보통 구현) -> 문 여는 것과 램프 디바이스보고 키는 것을 병렬적으로 한 후 다시 문을 닫으면 된다

cf. 읽을 줄 알면 되며 opt, loop,par를 구분할 수 있으면 된다.그리고 점선도 있고 실선도 있고 화살표도 존재

## 상호작용(interaction)

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%206.png)

**Alt** : 둘 중에 하나, t,f를 엘리베이터 이동이라는 객체에 보냄 

### 상호작용 이름

보통은 상호작용 이름만 적어도 되고 sd 키워드 적고 이름 쓰고 매개변수 써주고 반환값을 써줄 수도 있다.

–  상호작용에 부여된 이름으로서 시퀀스다이어그램의 좌측상단에 “sd”키
워드 뒤에 기술된다.
–  상호작용 이름은 다른 시퀀스다이어그램 또는 상호작용 개요 다이어그램에서 참조(ref)될 때 참조될 상호작용의 이름으로서 사용된다.

### 형식 게이트

갑자기 found로 들어오는 걸을 정확히 게이트로 써준다

- 상호작용의 외부로부터 수신되는 메시지를 표현할 떄 메시지 송신 지점을 표현할 때 사용된다.

### 반환 인자를 위한 생명선

- 상호작용은 인자와 반환인자를 포함할 수 있다

→ 상호작용의 반환 값은 상호작용과 동일한 이름의 생명선을 이용하여 표현할 수 있다.

- 상호작용 이름과 동일함
- 이런 객체가 있는 게 아니라 이 상호작용의 반환값이 t,f라는 의미!\

## 상호작용 이용(use)

- 상호작용 이용(interaction use)는 이미 정의된 다른 상호작용에 대한 참조(reference)이다.
    - 하나의 상호작용 안에 다른 상호작용이 존재, 이미 만들어진 상호작용을 사용하겠다

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%207.png)

사람이 하드웨어 층을 누름-> 층버튼 di에게 요청 -> 관리자한테 요청 -> 방향 선택하고 이동하라고 할 텐데 이때 여기 네모가 아까 만든 다른 데에서 reference로 사용 가능

Found 메세지가 그럼 이제 어디서 오는지 알 수 있다 : 사람이 층버튼을 누르면 층버튼di가 관리자한테 말해주면 관리자가 이동해라고 한다

## 액티브 클래스와 비동기 메시지

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%208.png)

- 도구를 사용하여 객체를 아이콘으로 표현할수도 있음
    - 사각형이 아니라 역할을 명확하게 해주기 위해 아이콘으로 표시하기도 함.
    - 도서주문관리 : 컨트롤 클래스
    - 도서주문시스템 si : boundary 클래스, 시스템 인터페이스가 된다.(외부 시스템(디바이스) 인터페이스, 유저 인터페이스도 가능), 다른 애와 의사소통 하는 부분
    - 액터(외부 시스템) : 개발 범위가 아님
- 외부 시스템과 일을 하려면 접근할 수 있는 시스템 인터페이스를 만든다 → 이 소프트웨어가 사용자와 상호작용하기 위해 유저 인터페이스가 필요하다.

### 1. 동기적 메시지

- 화살표가 다 지금 삼각형으로 되어있는 화살표
- 보통의 메소드 호출을 의미함, 함수호출

ex) scanf나 printf로 호출하면 두번쓰면 위의 꺼 실행하는 동안 일을 끝날 때까지는 그 다음 일은 블락되어있음. 그러나 쓰레드를 만들면 동시에 만들 수 있기 때문에 따로 돌고 메인. 쓰레드는 내일 을 할 수 있기 때문에 그 떄는 비동기임

### 2. 비동기 메시지(asychoronous)

- 삼각형이 없는 화살표
- 동기 메시지는 일이 끝날 때까지 기다려야 하지만 비동기는 안 기다려도 됨
- 호출자를 대기시키지 않는 메시지
- 비동기식 메시지를 이용하여 빠른 응답을 지원한다.

ex) 누가 도서구매 신청을 하면 주문관리는 이 일을 할 것 : 얘는 도서주문시스템한테 도서주문요청을 함-> 인터페이스가 받아서 실제 웹서비스로 요청할 것

근데 동기로 되어있으니까 도서주문 시스템은 웹이니까 답이 언제올지 모르지만 응답을 받을 때까지는 블럭됨

결과가 제대로 오면 리턴한다, 도서주문 요청 메소드는 결과가 올 때까지 블락되어있음

그다음 도서신청 결과로 가게 된다 그러면 도서구매신청 메소드가 끝나서 결과가 돌아옴

(정리)

기다려야 한다. 결과가 돌아올 때까지 5번까지 블럭되어서 기다려야 한다.

근데 요즘은 자바스크립트, 노드js는 비동기임, 빨리빨리 바꿔야 하니까

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%209.png)

누가 동기 메소드로 도서구매신청 -> 외부 시스템에게 도서 주문 요청하는데 비동기적으로 한다 즉, 요청만 하고 나는 그냥 돌아오는 것, 결과는 요청이 성공했다고 알려줌, 전자는 결과를 알려준 것 -> 그 사이에 도서주문시스템은 신청하는데 얘도 역시 비동기로 함(외부 시스템은 주로 비동기로 요청함) -> 1~5번 시간동안만 대기하게 된다. 그리고 도서주문시스템이 결과를 준다 -> 그걸로 도서주문관리로 비동기로 결과를 기록하라고 준다

도서주문관리는 신청했는지 알 수 없기 때문에 다른 애가 조회를 따로 한다.

일을 시키기만 하고 결과를 안기다리는 것을 말함 : 비동기

이전 예시)

일번 메소드를 호출한다는 건 스레드가 호출되는 것-> 쓰레드 하나로 일을 쓰는 것

지금 예시)

a 쓰레드가 1을 요청하면 2번까지는 하지만 받아서 일을 하는 것은 기다리지 않음, 두번째 박스를 하려면 새로운 쓰레드가 하나 더 만들어져야 함 : b라는 쓰레드가 필요

B는 3번을 하지만 a는 4번을 받고 보낸 후 끝남

도서주문 시스템은 도서주문시트템si에 요청하면 다른 쓰레드가 있을 거고 6청을 요청하는 쓰레드는 7번 하고 끝냄 -> 7번을 받는 쓰레드는 또 따로 있어야 한다

- 동기로 되어있는 경우는 쓰레드가 보통 한개로 구성
- 하지만 비동기가 들어오는 애들은 호출한 답이 들어오는 쓰래드를 별도로 갖고 있어야 한다

⇒ 클래스가 자신의 쓰레드를 가지고 있는 것을 **엑티브 클래스**라고 한다

들어오는 요청이 비동기니까 쓰래드가 따로 있어야 하고 도서주문과 도서주문시스템si 둘 다 별도의 쓰레드가존재해야 하므로 엑티브클래스여야 한다

### 액티브 클래스(능동 클래스)

- 클래스가 비동기적 메시지에 의해서  연산을 수행시키기 위해서는 클래스 독자적인 쓰레드를 가지고 있어야 한다
    - 호출하는 쓰레드 말고 호출을 받아서 별도로 일하는 쓰레드가 필요함
    - 비동기적 메시지를 받아야 하는 클래스
- 독자적인 수행 쓰레드를 가진 클래스를 능동(active)클래스라고 부른다.
- 객체를 나타내는 사각형에 양 끝에 선을 그어 표시

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2010.png)

## 메시지

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2011.png)

엘리베이터는 들어오는 화살표를 가지는 애들,즉 컨트롤러는 엑티브 클래스임

점선은 리턴임

대신 create가 있으면 객체를 생성한다는 의미임

생명선이 똑같은 애들은 이미 생성된 애들, O1은 6번에 의해서 생성됨

객체 파괴할 때는 x표시와 streo type을 추가해주면 된다

시퀀스 다이어그램은 위에서 아래대로 번호가 매겨져 있음

위에서 아래로 번호가 매겨져 있고 번호를 붙이는 순서는 툴마다 다르다

- 메시지는 상호작용의 생명선 간의 통신을 표현

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2012.png)

## 복합적 부분(combined fragment)

- 다양한 유형의 부분 상호작용을 복합적으로 표현

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2013.png)

### 상호작용 연산자

조그만 박스 안에 들어가는 이름을 의미

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2014.png)

- 관련된 클래스 다이어그램
    
    ![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2015.png)
    

클래스 다이어그램만 가지고는 못만들고 시퀀스 다이어그램도 만들어야 한다

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2016.png)

나가는 화살표는 c1클래스의 특정시점에서 2,3,4번을 호출한다 : interaction, 위임, 시퀀스와 클래스가 있어야 코딩이 가능함

![IMG_54474113B850-1.jpeg](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/IMG_54474113B850-1.jpeg)

Ex)

똑같은 클래스에 다른 시퀀스

비동기로 호출하니까 기다려야 한다

Par는 동시에 일어나야 한다(자바는 동시에 할 수는 없어서 수도코드로 적어놓음)

C4,c5는 여러개라서 여러개로 사각형 그림

C4 각각에 대해서 c4를 호출함

동시에 c5에 있는 것들을 c3을 호출

그 결과를 받아서 리턴타입에 따라서 쓰면된다.

R1이면 1,r2이면 2,r3이면 3을 호출

비동기니까 호출하고 끝남

그리고 특정 시점이 되면 c1에 비동기로 호출함

Critical이므로 임계영역이라서 이거 실행되는 동안 중가에 끼어들기 불가 : synchronized 키워드를 사용하면 된다

Op1,2를 호풀할껀데 동기화되는 부분임

Cf. 맴버변수는 기본이 private, 접근 지정자가 없다면 기본적으로 private이라고 두면 된다.

Default가 패키지 이긴 한데 안나와있으면 정보은닉이라고 생각하면 된다~

엑티브 클래스 쓰레드 구현 시 자바는 상속받거나 runnable로 하고 그건 언어마다 다름

⇒ 서로 보고 채워나갈 수 있다 : 일관성

# ✅클래스/시퀀스 다이어그램의 일관성

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2017.png)

- 보통은 클래스 다이어그램은 전체 구조를 보는 것이지만 동적인 측면을 볼 수 없기에 시퀀스로 동적인 측면을 볼 수 있고 이 두개는 상호보완적으로 알아야 한다
- 클래스는 반드시 객체나 생면선으로 보여야 하고 객체를 표현하는 클래스가 클래스다이어그램에 있어야 한다
- 클래스에 연산이 있다면 시퀀스에 메세지가 있어야 하고 메세지가 있다면 클래스에 표현되어야 한다
- 클래스 다이어그램에 관계가 있다면 메세지를 주고받는게 보여야 한다.

## 클래스/객체 규칙

- 시퀀스 다이어그램의 생명선은 반드시 클래스 다이어그램에 표현된 클래스의 인스턴스가 되어야 한다
- 클래스 다이어그램에 표현된 클래스는 반드시 시퀀스 다이어그램에서 생명선을 정의할 떄 사용되어야 한다.

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2018.png)

## 연산/메시지 규칙

- 시퀀스 다이어그램의 메시지는 메시지를 수신하는 객체의 클래스에서 연산으로 정의되 어 있어야 한다.
- 클래스 다이어그램의 모든 클래스의 각 연산은 반드시 시퀀스 다이어그램에서 메시지로 사용되어야 한다

![Untitled](6-1%20UML(%E1%84%89%E1%85%B5%E1%84%8F%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B3,%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7)%200b31fc83051440b089b0da9a276d37e6/Untitled%2019.png)

## 연관(의존) 관계/ 메시지 규칙

- 메시지가 전달되기 위해서는 전송 객체에서 수신 객체로 관계가 존재해야 한다.
- 두 클래스 사이에 연관(포함, 집합) 관계 또는 의존 관계가 있다면 두 클래스의 객체 사이 에 메시지가 전달되어야 한다.

cf.

한 시나리오에 모든 함수를 표현할 수는 없지만 모든 시나리오에는 모든 함수가 사용되어야 할 것

모든 시나리오를 그릴 수 없기 때문에 우선순위가 높은 시나리오 먼저 한다
