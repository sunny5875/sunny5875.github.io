# 12-1 Design Framework

솔리드에서 가장 언급되는 것이 OCP임. 확장에 오픈되어있고 변경에는 닫혀있다

S은 단일책임 원칙, O는 OCP, LSP 대체,I는 ISP/인터페이스 분리,D는 의존관리 역전/추상적인 것에 의존해야 한다

가장 실수하는게 liskov substitution

소프트웨어공학에 개발 프로세스에 대해서 보고 있음

요구사항분석을 먼저하고 요구사항->분석 -> 설계를 하는데 아키텍처 설계 후에 상세설계를 하고 있고 지금 설계에 대해서 하고 있음

# 설계

![Untitled](12-1%20Design%20Framework%20f4d744f588d7419bafd275f5651b9d55/Untitled.png)

- 제일 큰 설계가 아키텍처 설계, 덩어리가 머가  있고 그 사이의 관계에 머가 있는지 설계/구현 시 어떤 규칙을 지켜야하는지에 대해서 결정 이 때에는 스타일이 존재해서 그것을 가져다가 사용
    
    아키텍처 설계 완성 후에 큰 틀이 완성되므로 그 안에서 변경없이 설계됨
    
- 서브시스템 설계 시 클래스들이 나오고 클래스 간의 관계가 나오고 설계패턴이 적용됨

패턴의 종류가 많은데 아키텍처 패턴도 존재함

POA라는 책이 있는데 큰 아키텍처에 대한 패턴도 존재함. 아키텍처 설계 시에도 패턴 적용 가능함

- 클래스 설계
- 클래스 안에 있는 메소드 설계

# Design Pattern

무조건 클래스를 뽑아내고 연관관계나 이런것을 만드는 것이 아니라 설계를 많이 해본 사람들이 패턴을 만들어냄.  패턴에 맞춰서 기본 틀을 두고 그 안에서 모양을 바꿈.

- 소프트웨어를 설계할 떄 특정 맥락에서 자주 발생하는 고질적인 문제들이 발생했을 때 재사용할 수 있는 훌륭한 해결책
- 프로그램 개발에서 자주 나타나는 문제를 해결하기 위한 방법 중 하나로, 소프트웨어 개 발과정에서 발견된 Know-How를 축적하여 이름을 붙여 이후에 재사용하기 좋은 형태로 특정 규약을 묶어서 정리한 것
- GoF(Gang of Four)의 디자인 패턴
– 생성 패턴:객체의 생성에 관련된 패턴, 생성을 어떻게 하는가
– 구조 패턴: 클래스를 조합해 더큰구조를만드는패턴, 클래스간의 구조와 관련된 패턴
– 행위 패턴: 알고리즘이나 책임의 분배에 관한 패턴, 클래스가 일을 하는데 일에 대한 행위 패턴

설계 시 미리 정해진 패턴들이 있고 보통 상황이나 문제가 주어졌을 때(알고리즘이나 전략이나 구현의 절차들이 자주 바뀌는 경우,맥락,상황) 전세계 유명한 객체설계를 하는 사람들이 각자 해결하는데 나중에 보니까 같네? 모아놓는 것, 문제를 풀다보면 기본 틀을 대부분 동일하기 때문

똑같은 상황에서 유명한 개발자들이 다 해결하다보니까 문제해결하는 게 있던 것

자기만의 패턴이 생겼는데 모아놓으니까 똑같네! 이렇게 되는 것, 고질적인 문제를 해결할 수 있는 해결책

패턴의 종류가 많은데 보통 gof의 디자인패턴을 의미, 23개의 패턴을 모아놓음

![Untitled](12-1%20Design%20Framework%20f4d744f588d7419bafd275f5651b9d55/Untitled%201.png)

재사용하는 도구 + 의사소통하는 도구

객체생성할 때 무슨 패턴 쓰면 되겠다! 이렇게가 가능

# Framework

틀을 의미, 소프트웨어 개발 시 전체 틀을 의미, 첨에 설계할 때 틀을 설계하는 것을 아키텍처 틀이라고 하는데 반복적으로 발생하는 아키텍처가 존재함. 도메인 부분만 달라지지 돌아가는 프레임은 동일함. -> 전체 큰 틀을 미리 만들어놓고 반복되는 구조와 기능을 추상화시켜서 만들어놓음.

- Framework는 어플리케이션을 개발할 때, 아키텍처에 해당하는 골격 코드(반복되는 구조/기능을 추상화 시켜 놓음)를 제공함
– Solution : 완제품
– Framework : 반제품, 반은 구현되어있고 나머지 반은 개발자가 하는 것, 도메인에 맞춰서 만들고 나머지 처리는 동일, 원래는 아키텍처가 설계하고 코딩을 했었지만 프레임워크가 다 처리해주니까 기본적인 구성에 대해서는 생각할 필요가 없음.
    - 완전한 애플리케이션이 되기 위해서는 프레임워크를 확장하여 비즈니스 요구사항을 만족시키는 작업 필요
    - 확장이 프레임워크의 기본 구조에 영향을 끼치지 않음
    - 디자인 패턴이 적용됨
- 소프트웨어에 직면한 생산성 문제를 재사용을 통해 해결하려는 방편 중의 하나
- 프레임워크가 없다면?
    - 처음부터 네트워크 구성, 디비 객체 생성, 티비 connection 생성 다 일일히 했었는데 자주 쓰는 부분을 꺼내서 확장해서 도메인의 비지니스 요구사항을 만족시키는 작업 필요
    - 똑똑한한 아키텍트가 틀을 구현하고 다 만들어야 하고 아키텍처 위에서 자신의 일을 하지만 프레임워크가 있다면 아키텍트가 커스터마이징을 하면 시간이 줄어든다. 똑똑한 개발자들이 없다면 수준이 떨어지므로 개발자의 수준에 따라서 자지우지하게 됨. 프레임워크자체가 품질을 보장해주는 것. 최소한의 생산성은 만족시킬 수 있음
- 확장은 프레임워크의 기본구조에 영향을 끼치지 않음.

프레임 워크를 쓰게 되면 완성도의 중요한 부분을 이미 다 만들어놨기 때문에 기본 어느 정도의 수준은 만들 수 있지만 프레임 워크는 규칙이 있기 때문에 진입이 어려움

## framework의 구조

- **Cold spot(콜드 스팟)** : 절대로 바뀌지 않는 부분, 변경 불가,이미 다 구현, 변경되지 않고 반복적으로 재사용되는 부분
- **Hook point(확장포인트)** : 확장될 수 있는 포인트,인터페이스/추상클래스로 결정되어있음(트렌젝션을 쓰려면 약속된 인터페이스를 오버라이딩하면 됨, 프레임워 크가 알아서 돌아감)
- **hot spot(핫스팟)** : 개발자에 의해 확장 가능

![Untitled](12-1%20Design%20Framework%20f4d744f588d7419bafd275f5651b9d55/Untitled%202.png)

## IOC(Inversion of Control) : 제어의 역전

- 개발자는 확장 포인트를 상속받아서 비지니스 모듈을 개발
- 개발된 모듈은 프레임워크의 코어 부분이 호출하는 구조로 바뀜
- 클래스 라이브러리와 프레임 워크의 차이점

![Untitled](12-1%20Design%20Framework%20f4d744f588d7419bafd275f5651b9d55/Untitled%203.png)

![Untitled](12-1%20Design%20Framework%20f4d744f588d7419bafd275f5651b9d55/Untitled%204.png)

(라이브러리)

DIP : 의존관계 역전, 추상적인 것에 의존해야 한다. 변하지 않는 것/인터페이스/추상클래스에 의존해야 한다

프레임 워크가 나오기 전에는 그냥 쓰다가 라이브러리를 가져와서 사용, 라이브러리를 call/호출해서 사용, 주도권은 개발자가 가지고 있음

(프레임워크)

- 주도권을 프레임워크가 가지고 있음 규칙을 지켜야 동작이 됨 동작인 프레임워크가 내꺼를 호출함
- 프레임워크는 이미 약속이 있고 돌아가기 위해서 인터페이스를 맞게 구현하고 프레임워크가 호출해서 사용,
    
    어플리케이션이 크게 될 경우 네트워크 처리 이런거에 시간을 빼면 안된다.
    
- 객체생성도 우리가 하지 않고 객체도 프레임워크가 주입해줌

### 라이브러리 vs 프레임워크

- 중요한 차이점 : inversion of control
- 라이브러리
    - 클래스의 집합으로서 코드의 재사용성을 지원
    - 제어의 주체가 개발자, 코드에서 라이브러리 함수를 호출
- 프레임워크
    - 제어의 주체는 프레임워크 , 프레임워크에서 개발자의 코드를 호출/ 제어의 역전
    - 프레임워크에서 기본적인 골격을 잡아놓았기 때문에 우리는 제어읭 호름에 맞게 코드를 작성해두면 프레임워크에서 호출
    - 개발자는 도메인(애플리케이션의 핵심로직)에만 집중할 수 있고 기본은 프레임워크가 다 해준다

프레임워크 내에 규칙이 있고 c로 코딩할 떄는 내가 제어하지만 프레임워크 안에는 다 알고 있어야지만 끼워넣을 수 있어서 진입장벽이 높은 편

### 프레임워크의 장점

- 높은 생산성, 코드 품질 보장
    
    개발자들에 따라서 소프트웨어품질이 좌지우지되는데 프레임워크를 쓰면 기본 생산성은 유지됨