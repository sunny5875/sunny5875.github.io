# 14-1.testing

소프트웨어 공학 프로세스 중에 설계가 있고 아키텍처와 모듈 설계로 디자인 패턴하고 구현 시에는 코딩 규약을 만들어야 한다. 코딩하고 나서 리팩토링에 대해서 배웠는데 오늘은 테스트 할 것

## 소프트웨어 오류로 인한 사고 사례

ex) 걸프전 당시 페트리어트 미사일 실패, 방사선 치료기 테락-25 사고, 상업용 우주선 아리안 5호의 공중 폭발

- 테스트가 중요한 이유는  소프트웨어의 사소한 결함이 대형사고를 만들어낸다. 소프트웨어결함이 하드웨어보다 더 크게 결함을 만들기에 더 잘 만들어야한다. 결함없이 잘 돌아가는 것을 잘 테스팅해야 한다

# Testing

결함이 없고 처음 요구했던 목적에 맞도록 소프트웨어가 만들어졌는지 테스팅해야 한다

여러 사람들이 테스팅에 대해서 정의함

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled.png)

- 명시된 요구를 잘 만족하는지 예상이 실제결과와 얼마나 보이는지 평가
- 테스트는 첨에 요구사항을 만족하는지 확인할 텐데 명세가 완벽하지 않을 것이며 명세를 만족하는지를 테스트하는거지만 명세가 맞다고도 할 수 없으며 시스템이 맞다고도 할 수 없는 것이므로 완전히 테스트 할 수는 없다
- 테스트는 결함이 없다는 것을 보여주기보다는 결함이 있음을 보여주는 것

결함이 없는 시스템을 증명할 수 없으니까 테스팅의 목적은 시스템이 완벽하다가 아니다!! 테스팅 하는 것의 목적은 결함이 있음을 찾아내는 것이고 그 결함은 개발팀끼리 고객이랑 얘기해서 보안하고 넘어갈 것인지 안고 갈건지 결정

→ 결함이 있음을 가정하고 먼지 찾아내자!

## Testing의 목표

**작은 의미**

- 소스코드 속에 있는 오류를 찾아내는 것,디버깅
- 원시 코드 속에 남아있는 오류를 발견하는 것
- 결함이 생기지 않도록 에방하는 것

**큰 의미**

- 개발된 소프트웨어가 고객이 요구한 것을 만족하는지 확인하는 것
- 개발자와 고객에게 사용하기에 충분한 소프트웨어임을 보여주는 것

→ 개발된 소프트웨어에 품질을 높여주기 위한 작업

일반적인 의미는 큰의미이고 개발자 입장에서는 작은 의미가 되는 것

⇒ 소프트웨어 테스팅은 소프트웨어에 결함이나 원치 않는 동작을 찾아내고 소프트웨어가 요구와 제약에 맞는지 거증하는 작업

완벽하다는 것이 아니라 결함이나 원치않은 동작을 찾아내고 요구와 제약이 맞는지 검증하는 작업

테스팅의 주 목적은 완벽하다는 것을 하면 한도끝도 없고 앞뒤도 안맞으니까 오류를 찾고 어떻게 할 것인지 결정

오류를 찾기 + 사용자가 원하는 요구와 맞는지 확인

## testing 원리

- 오류를 발견하려고 프로그램을 실행시키는 것
- 완벽한 테스팅은 불가능
- 테스팅은 창조적이면서 어려운 직업
    - 어떤 테스트 케이스를 넣어서 돌리르냐에 따라서 몇번의 테스트 케이스로 커버될 수 있는 것, 좋은 소프트웨어를 만드는 회사는 테스팅 전문가가 존재
- 오류의 유입을 방지할 수 있음
- 구현과 관계없는 독립된 팀에 의해 수행되어야 한다
    
    구현과 관계없는 팀에 의해서 수행함. 남코드는 잘찾고 내코드는 못찾으니까 독립적인 팀이어야 함
    

## testing 과정

- 시험할 소프트웨어에게 테스트 케이스를 주어 실행시킨 후 시스템의 동작이 예상한 대로 실행되는지 확인하는 것

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%201.png)

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%202.png)

## 테스트 케이스

- 테스팅을 잘하기 위해서 목적은 결함이 있다라는 것을 찾아내느 것이므로 결함의 존재를 잘 드러내는 좋은 테스트케이스를 찾는 것이 중요
- 테스트 케이스는 시험 대상 단위 별로 묶어서 미리 준비

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%203.png)

한 row가 테스트 케이스임

아이디와 비번에 넣어가서 들어가지면 되는 것, but 정상흐름은 잘 오류가 잘 안생김. 대체흐름에서 빈칸넣고 특수문자를 넣으면 오류 메세지가 떠야하는데 이런걸 잘 찾아내야 함

아이디에 들어갈 수 있는 언어의 종류가 제한될 수 있으므로 테스트케이스 하나로 커버리지를 크게 할 수 있음

→ 어려운 작업이니까 테스팅 팀이 따로 있어서 같이 이해당사자이기 때문에 들어가서 얘기하고 그럼

- Use-case driven test, 유스케이스 기반으로 테스트를 하기 때문에 기본흐름, 대안흐름이 있는데 대부분 기본흐름보다는 대안흐름을 찾는 것이 중요하며 대안흐름을 가지고 테스트 케이스를 하는 것
    
    사용자가 정상적으로 실행하지 않기 때문, 결함의 존재를 잘 드러내는 좋은 테스트 케이스를 찾는 것이 중요하고 커버리지가 큰 테스트케이스를 뽑는 것도 중요
    

## 소프트웨어 개발 단계에 따른 테스트

## V 모델

- 소프트웨어 개발 단계의 순서와 짝을 이루어 테스트를 진행해나가는 방법
- 프로젝트 초기 단계부터 테스트 계획을 세우고 테스트 설계 과정이 함께 진행

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%204.png)

원래는 이런 식으로 가는데 각 개발 프로세스의 각각의 과정은 테스트에 대한 설계를 같이함

왼쪽은 개발, 테스트는 오른쪽

- 요구분석 시 시스템 테스트도 같이 고려함, 요구사항이 맞는지, 비기능 기능 요구테스트가 맞는지
- 아키텍처설계시에는 서브모듈이 통합되는 것, 함수가 정보를 잘 넘어가는지 그런걸 테스트
- 큰 모듈이 인터페이스를 잘 주고받는지 통합 설계를 하고 모듈 설계 뿐만 아니라 개발자가 단위테스트를 하는데 그것도 미리 설계, 그다음 구현한 후 테스트 다한 뒤 마지막으로 사용자한테 넘겨주는 인수테스트까지

# 단위 테스트(Unit test)

- 프로그램의 기본 단위인 모듈을 테스트
- 주로 모듈을 구현한 프로그래머가 테스팅함
- 모듈 테스트 시 상위/ 하위 모듈이 개발이 안된 경우
    - 가상의 상위, 하위 모듈을 만들어 사용
    - **테스트 드라이버(test driver)** : 상위모듈의 역할, 테스트할 모듈을 호출
    - **테스트 스텁(stub)** : 하위 모듈 역할

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%205.png)

내 모듈을 누가 호출하는데 정보가 제대로 넘어와야 돌아가므로 가상에 호출하는 것이 드라이버 모듈이고 가상으로 만들어서 넘겨주는 껍데기만 만들어서 테스트하고 내가 만든 모듈을 테스트할 건데 내가 다른 모듈을 호출할 수도 있음. 제대로 넘어가야 모듈이 완성된 것이므로 호출하는 모듈이 스텁 모듈, 둘다 껍데기만 있는 것이고 테스트 툴이 알아서 만들어짐

→ 자기가 개발한 모듈 테스트 시 나를 호출, 내가 호출하는 것을 만들어서 실제 다른 애들이랑 돌아가는지도 확인해야 끝나는 것

# 통합 테스트(integration test)

각자개발자가 단위테스트를 했다면 이제 합쳐야함. 그게 통합 테스트

- 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생할 수 있는 오류를 찾는 테스트
- 모듈 간의 상호작용이 정상적으로 수행되는가 테스트
- 모듈 사이의 인터페이스 오류는 없는지, 모듈이 올바르게 연계되어 동작하고  있는지 체크
    
    로직을 보는게 아니라 모듈 간의 상호작용이 정상적으로 수행되는지 안의 로직을 구체적으로 보는게 아니라 인터페이스를 보는 것
    
- 통합 시 세가지 방법이 존재
    - 빅뱅, big bang
    - 하향식, top down
    - 상향식, bottom up

### 통합 테스트 - 빅뱅 통합

- 단위 테스트가 끝난 모듈을 한꺼번에 결합하여 수행하는 방식
- 소규모 프로그램이나 프로그램 일부를 대상으로 하는 경우에 적합
- 오류 발생 시 어떤 모듈에서 오류가 존재하는지 그 원인이 무엇인지 찾기가 어려운 편

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%206.png)

### 통합 테스트 - 하향식 통합(top-down)

통합시 위에서 아래로 할 것이냐 아래에서 위로 할 것이냐에 따라서 나뉘는데 top down은 위에서 아래

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%207.png)

- 모듈의 계층 구조에서 맨 상위의 모듈부터 시작하여 점차 하위 모듈의 방향으로 통합
    - 상위 모듈 : 시스템 전체의 흐름을 광장
    - 하위모듈 : 각 기능을 구현
    
    맨위의 모듈이 전체를 제어하고 제일 아래가 수체적으로 일하는 모듈임. 위에서부터 테스트하고 구동하는 가상의 드라이버를 만들어서 테스트를 하고 그 후에는 밑에 꺼를 해서 연결하고 그 다음에 인터페이스가 되는지 확인
    

**장점**

- 윗부분은 시스템 흐름을 관장하기 때문에 프로그램 전체 흐름을 영향을 주는 것을 미리 감지할 수 있다.
- 전체 흐름 중에서 머가 안된다는 빨리 발견 가능

**단점**

- 하위모듈이 임시로 만든 스텁들로 대체되어 결과가 완전하지 않을 수 있음
- 스텁 수가 만을 경우 스텁을 만드는데 시간과 노력이 많이 걸린다
- 밑에가 없으면 스텁을 만들어야 하는데 누군가 구현하고 있으니까 스텁만드는 시간과 구현하는 시간이 있어서 시간이 오래걸림

⇒ 모듈 간의 인터페이스와 시스템의 도작이 정상적으로 잘되고 있는지 빨리 파악할 때 유용

스텁이 다 구현되지 않았기 때문에 스텁이기 때문에 돌아간도 해도 전체 시스템이 완전하다고볼수는 없음

## 통합 테스트 - 상향식 통합(bottom-up)

Bottom up은 다만들고 시작하니까 스텀을 만드는 시간이 덜함

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%208.png)

- 가장 밑단에 있는 최하위 모듈부터 테스트
- 상위 모듈의 역할을 하는 테스트 드라이버가 필요

**장점**

- 최하위 모듈들을 개별적으로 병행하여 테스트
- 하위에 있는 모듈들을 충분히 테스트 가능
- 정밀한 계산이나 데이터 처리가 요구되는 시스템의 경우 유용

**단점**

- 상위 모듈에서 오류가 발견되면 그 모듈과 관련된 하위 모듈을 다시 테스트해야 함
- 초기에 시스템의 뼈대가 갖추어지지 않음
- 상위층의 중요한 이너페이스가 마지막 가서야 확인 가능

마지막 모듈 구현 후에 끝에서부터 테스트해서 스텁 대신에 완전 구현된 애들로 하기 떄문에 하위 모듈이 테스트가능하고 복잡하다면 이게 더 편함

단 문제가, 로직처리해주는 부분이 먼저 올라가서 오라가니까 전체 구성이 잘 보이지 않고 밑에서는 잘되는데 위에서 오류가 나면 다시 밑에서 부터 테스트해서 올라가야 한다

전체 시스템 뼈대를 테스트하기는 어렵다

⇒ 통합 테스트는 모듈들의 연동을 테스트하는 것이고 이후에는 시스템이 만들어진 것이므로 시스템이 정상적으로 체크하는지 테스트

# 시스템 테스트(system test)

- 시스템 전체가 정상적으로 동작하는지 체크
- 모듈이 모두 통합된 후 사용자의 요구사항들을 만족하는지 테스트
- 사용자에게 개발된 시스템을 전달하기 전에 개발자가 진행하는 마지막 테스트
- 실제 사용환경과 유사하게 테스트 환경을 만들언호고 요구 분석 명세서에서 명시한 기능적, 비기능적 요구사항을 충족하는지 테스트, 주로 비기능
- 부하를 주는 상황(stress)에서 수행, 비기능적 테스트를 중심으로 수행

# 인수 테스트(Acceptance test)

같은 시스템 테스트인데 인수한다는 의미로 실제 사용자가 테스트함 사용자가 만들어진 시스템을 맞게 돌아가는지 사용자 요구사항에 맞는지 인수할건지 말건지 판단

- 시스템이 예상대로 동작하는지 확인하고, 요구 사항에 맞는지 확신하기 위해 하는 테스트
- 시스템을 인수하기 전 요구 분석 명세서에 명시된 대로 모두 충족시키는지를 사용자 가 테스트
    - 목적: 사용자 주도로 이루어지며, 오류 발견보다는 제품의 출시 여부를 판단하는 것
    - 인수 테스트 결과: 시스템을 출시할지, 출시 시기를 늦추더라도 보완할지 결정
    
    보통 시스템 테스트까지 하면 보통의 오류는 잡혔고 사용자는 원하는 게 맞는지 말건지 출시할건지 말건지 결정하는 것, 맘에 안든다면 춞시 시기를 늦출껀지 좀더 할 것인지 판단
    

**테스트 유형**

- 알파 테스트
• 선택된 사용자가 개발 환경에서 시험하는 것 ex) 회사에 가서 테스트
- 베타 테스트
• 선택된 사용자가 외부 환경에서 시험하는 것(필드 테스팅)

# 테스팅 방법에 따르 테스팅 구분

테스팅 방법은 매우 많은데 크게 두가지로 나뉨

## 1) 블랙박스 테스팅

블랙은 내부구조를 보지 않고 함수의 입력을 줄 떄 출력이 잘나오는지 그것만 확인

화이트 박스는 안이 다보이고 블랙은 안보이니까 출력이 맞느지만 확인, 알고리즘을 보지 않음

- 입력값에 대한 예상 출력 값을 정해놓고 그대로 결과가 나오는지 체크
- 프로그램의 내부의 구조나 알고리즘을 보지 않고 요구 분석 명세서나 설계 사양서에서 테스트 케이스를 추출하여 테스트
- 기능을 어떻게 수행했는가보다는 사용자가 원하는 기능을 수행했는가를 테스트

## 2) 화이트박스 테스팅

안의 로직을 다보고 논리적 구조를 다 보는 테스팅

- 모듈의 논리적인 구조를 체계적으로 점검하는 구조적 테스팅
- 여러가지 프로그램 구조를 기반으로 테스트

![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%209.png)

if로 가면 두가지 다 테스트해봐야하고 switch면 모두 다확인해봐야하므로 테스트케이스가 매우 필요

# 객체지향 테스팅  : 사용사례 기반 테스팅

일반적인 테스트의 개념이고 이제는 객체지향 테스팅(udd, usecase driven development)

- usecase 명세로부터 테스트 케이스 추출
    - 엑터의 입력과 액션을 파악
    
    ![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%2010.png)
    
    - 입력값 결정
    
    ![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%2011.png)
    
    - 테스트 케이스 생성
    
    명세서에 있는흐름을 보고 기본,대체흐름으로부터 테스트케이스를 추출
    
    ![Untitled](14-1%20testing%2019aff0e70cd04ca98e51722e1e42a05a/Untitled%2012.png)
    

테스트 케이스가 엄청 많이 나오며 이 조합을 도려볼 떄 증명한다면 선택하고 조합이 오류를 발견할 수 있다면 선택

근데 중복되는 애들이 있다면 삭제, 3과 4가 중복되니까 하나를 제거

테스트 커버리지를 찾아서 중복되는 것은 제거