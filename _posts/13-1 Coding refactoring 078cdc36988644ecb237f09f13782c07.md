# 13-1. Coding refactoring

지금은 우리는 코딩에 대해서 알아보고 있음

코딩 시 코딩 규약을 지키고 설계단계에 나온 문서와 프레임워크부터 코딩에 들어간다. 클래스, 메소드 코딩하고 인스팩션하고 단위 테스트하고 통합테스트를 위해서 코드를 릴리즈한다

리팩토링이라고 해서 코딩 후에 여러명이 돌아가면서 코딩을 돌아가면서 함. 코딩하다고 변경이 생길 수 있고 유지보수하는 것이 변경이 발생할 수 있기 때문에 쉽게 대응할 수 있게 OCP에 만족하도록 코드를 수정해야 한다. 단 실행결과는 바뀌지 않도록 한다. 결국 하다보면 디자인 패턴이 적용이 된다. 디자인 패턴과의 차이는 디자인 패턴은 설계단계에서 하는 것이고 리팩토링은 코딩단계에서 코드를 보고 다시 유연한 코드로 바꾸는 것을 의미

하지만 결국은 디자인 패턴이  나오는 경우가 많음

DEAD CODE SMELL이라는 코드가 나올 경우(맴버변수와 메소드가 반복된다면 클래스로 뽑기, 부분이 길다면 쪼개고 등등의 목록을 보면서 작업을 수행)

# 프린터 관리 예제

원하는 대로 실행이 되도록 코딩이 되어있는 상태

코드를 보고 리팩토링을 할 때 dead code smell, 너무 긴걸 찾거나 if문이 있거나 변수의 타입이 들어가거나 중복되는 경우

## 버전 1

프린터는 동일하게 가지고 있는 코드가 존재, 이런 중복된 코드를 수정 시 여러군데에서 고쳐야 하니까 하나로 모아야 한다.

→ 세개의 프린터는 구체적인 프린터니까 중복된 속성과 메소드를 뽑아서 클래스를 뽑아낼 수 있다

변수와 함수가 같은 기능을 수행함. 동일한 로직이 산재되어있다면 메소드를 만들고 속성과 메소드가 비슷한게 존재한다면 클래스를 뽑아야 한다.

*클래스들이 동일한 종류이며 클래스 추출하기, 세가지 프린터기는 프린터라는 것을 만들 수 있다. : 상위 클래스 추출하기*

Print라는 슈퍼 클래스를 만들고 그안에 중복된 속성과 메소드를 위로 올린다. Dead code smell은 중복코드! 세개의 프린터에 id, get id, print 등의 동일한 이름이 있는 경우

- 슈퍼 클래스를 추출해내세요!

## 버전 2

공통된 속성과 메소드를 뽑아서 클래스를 만들어서 나머지 클래스는 is-a관계를 가지니까 상속으로 리팩토링

Bad smell : 중복이 된 코드 ,잉크젯 프린터를 보면 프린트하는 기능은 가능한지 물어보고 출력하고 안가능하면 경고 출력, 레이저 프린터도 프린트 가능한지 물어보고 가능하면 프린터하고 안가능하면 Alert를 띄움, 일의 순서는 같은데 프린터하는 내용만 다름

도트는 프린트 가능한지 물어보고 출력하고 항상 가능해서 else가 없지만 얘도 같은 구조를 만들 수 는 있음.

→ 일의 순서가 동일 어떤 메소드 안에 순서는 똑같고 구현 방식만 다르다면 답은 템플릿 메소드 디자인 패턴!(command pattern은 명령을 invoke하는 애랑 수행하는 애가 다를 경우)

: 틀은 있고 구체적인 hook method를 오버라이딩하는 형태

반복되는 코드를 여기저기 둔다면 일의 순서를 바꾸고 싶다면 여러군데를 고쳐야하고 유지보수하기 어려워 진다. 변경에 열려있게 된다 -> 일의 순서를 한곳으로 모은다 : template patten

→ printer 클래스의 print메소드에서 뼈대 구조를 옮겨 template method로 해서 틀을 잡아준다. 대신 하위 클래스의 함수들은 클래스마다 구현이 다르니까 각 단계에 대응되는 hook method를 구현하며 printer클래스에서는 구현할 수 있도록 Abstract으로 바꿔준다.

순서는 슈퍼 클래스로 올리고 달라지는 부분은 abstract으로 하자 : template method pattern

구조가 동일하니까 template을 만들어서 리팩토링 해서 구조를 위로 끌어올린 형태

*하위 클래스 메소드들 중 코드 뼈대의 구조가 중복되는 경우 템플릿 메소드 만들기*

## 버전 3

잉크젯 프린터를 보면 맴버변수로 id 외에 잉크의 용량과 reduction rate를 가지고 있고 레이저 프린터기도 토너의 용량과 reduction rate를 가짐

즉, 잉크젯과 레이저는 개념적으로는 똑같은 애들이 있음. 이름만 다르게 가지지 동일한 것임

- 레이저와 잉크젯은 동일한 내용을 중복해서 가지는 것 -> 이걸 뽑아서 클래스로 만들고 이걸 맴버변수로 가지면 된다. 상속관계는 아니고 용량과 관련된 맴버변수를 가지고 필요 할 때마다 호출해서 위임시키면 된다.

카트리지를 만들어서 잉크나 토너를 합친 개념 두군데 공통적으로 있던 애를 묶음.

클래스를 만들고 잉크젯과 레이저는 묶어서 카트리지를 가지게 됨.

변수 두개가 결국 같은 개념이기에 카트리지 클래스로 추출하고 코드를 위임시키도록 바꿈.

*중복된 코드인데 공통된 속성이 있는 경우 그것과 관련된 속성과 함수를 합쳐져 클래스로 생성 : 클래스를 추출하기* 

## 버전 4

printer와 pdf writer는 비슷한 기능을 수행하고 있지만 프린터 클래스와 pdfwriter는 is a 관계로 묶을 수 없음. 하지만 print라는 동일한 기능을 가지고 있음

→ Interface으로 묶자!! Is a 관계가 아니여도 묶을 수 있음, 추가적으로 main class에 있는 printWelcom()메소드의 파라미터타입이 Printable 인터페이스이므로 printer, pdf writer모두 넘겨질 수 있음

*관계없는 다른 클래스와 공통된 메소드가 존재하는 경우 인터페이스 추출하기*

## 버전 5

용량을 받아와서 뺄셈을 하고 setter로 바꾸는데 결국은 카트리지 클래스에서 계산하는 것이 아니라 프린터 클래스에서 계산한 것! 

잉크젯 프린터는 id와 카트리지를 가리키고 있는데 잉크젯은 프린트하는 기능이 있고 맴버변수의 카트리지의 값이 바뀌는데 이 작업은 프린터에서 바꾼 게 문제, capacity는 잉크젯이 가지고 있는 속성이 아니라 카드리지가 가지고 있는 속성임

- 카트리지가 갖고 있는 속성을 프린터에서 바꾸고 있음

→ 카트리지에게 일을 시키도록 isAvailable, consume 메소드를 만들어야 한다. 위임시킨다.

*메소드가 다른 객체의 메소드 반환값을 이용하여 일을 하는 경우, 메소드가 자신이 속하지 않는 클래스에 더 많이 접근하는 경우 메소드 이동하기(잘못된 소속)*

## 버전 6

- 용량과 리덕션 rate가 있고 조작한 메소드는 다 printcatriage가 가지고 있음. Reduction capacity를 일부로 숨겨놓았는데 reductionCapcity는 계산도 없고 그냥 리턴만 함. 이걸 외부에서 호출할 때에는 의미가 있지만 안에서는 의미가 없음. : 과도한 메소드 사용

*특정 메소드가 이름만큼 너무 간단한 일을 수행하는 경우 메소드 합치기(과잉 중개 메소드)*

⇒ 코딩 중에 개발 프로세스 중에 코딩을 보고 있고 코딩 규칙을 만들어야 하고 코딩 한 뒤에 인스팩션 한 후에 리팩토링을 한다. 리팩토링을 하면 변화에 대응하기 쉽고 읽기 쉬운 코득다 만들어지고 결국은 디자인패턴에 적용된 코드가 된다.

# 회사원 봉금 관리 예제

## 버전 1

Employee를 하나로 만들어서 관리자와 평직원을 표현하기 때문에 type으로 표현함

- employee를 일반직원과 매니저로 쓰려고 c에는 상속이 없어서 이렇게 하지만 사실은 employee 중에서 평직원, 매니저 이렇게 상속으로 써야 한다.
- mangeES는 일반직원과 매니저는 이 메소드 하나에 각자 하는 일이 다르므로 if else문으로 했는데 직원의 종류가 늘어난다면 상수도 늘어야 하고 es 메소드도 if else가 더 늘어나야 한다. 새로운 직원이 올 때 마다 employee class를 수정해야 한다

→ 변경에 닫혀있는 코드, OCP

하나의 클래스를 키값으로 분리하는 것보다는 상속을 써야 하고 ES는 다형성을 써야 한다

- 메소드 이름도 좀 더 길게 이름을 보자마자 의미를 알 수 있어야 한다.
    
    보고 머하는 건지 가독성이 있어야 한다
    
    명명규칙도 잘못됨
    

![Untitled](13-1%20Coding%20refactoring%20078cdc36988644ecb237f09f13782c07/Untitled.png)

type에 따라 manageES행위가 달라지므로 *타입 코드를 하위 클래스들로 바꾸기, 조건문을 polymorphism으로 변경하기,* 

*manageES()메소드 이름만으로는 기능을 알기 힘듦으로 메소드 이름바꾸기 리팩토링*

## 버전 2

- main 메소드 하나가 길이가 너무 긴 편
    
    급여 출력, 객체 생성하고 급여 인상, 매니저 출력하는 기능 , 하나의 메소드에 너무 많은 메소드가 존재
    

*특정 메소드가 한가지 이상의 기능을 포함한 경우 메소드 추출하기(장황한 메소드)*

## 버전 3

- mereclerk, manager의 생성자에서 name, salary를 초기화하는데 만약에 얘가 변경이되면 다 바꿔야 한다. 기본 객체지향 기본개념 에서도 잘못 된 것. 자신의 데이터만 건들여야 하는데 name, salary는 employee가 갖고 있는 속성, 즉 employee에서 일을 다해줘야 하고 Super로 해야 한다.(부모 생성자 호출, 부모 생성자에게 위임) : pull up
- 아까 매니저는 매니저를 못가진다고 했는데 employee는 모든 직원이 가지는 이름과 연봉 달리 manger도 가지고 있음. 직원은 세가지를 다 가질 수 있지만 manager는 manger를 가질 수 있지만 가지며 안됨. 즉 부모 클래스에서는 동시에 모두 가지는 것만 가져야 한다. 하지만 manager는 가질 수 없으므로 manager를 mereclerk으로 끌어 내려야 한다 : push down

*메소드를 하위 클래스로 내려보내기, 속성을 하위 클래스로 내려보내기*

![Untitled](13-1%20Coding%20refactoring%20078cdc36988644ecb237f09f13782c07/Untitled%201.png)

## 버전 4

- print-manager()는 mereclerk과 의존관계를 가지는데 manager가 가지고 있어야 한다.print는 의존관계를 mereclerk과 manager 둘 다 가지고 있음 : **method chain**

만약에 매니저 의존관계가 없는데 굳이 매니저를 의존관계를 가질 필요가 없다 -> 직원한테 물어봐서 직원이 매니저를 데리고 와서 이름이 머니 한 격

→ clerk에게 그냥 이름만 달라고 한다. 매니저에게 가져오라고 하지 않고

*특정 객체를 얻기 위해 여러 개의 객체를 거치는 경우 위임 감추기 리팩토링(message chains)*

Cf. print-current salary를 임플로이에 넣으면 안되냐?

그렇게 해도 됨. 그냥 쪼개려고 한 거임. 현재 급여를 출력하는 기능을 직원에게 가지게 해도 상과없음.

# 벡터를 이용한 스택 예제

백터는 동적할당되고 무한대 할당되니까 미리 고정할 필요가 없음. 구현을 편히 하기 위해서 vector를 사용

## 버전 1

객체지향은 상속과 위임인데 그 중 상속을 사용

- 재사용관점에서 볼 때 상속받으면 내꺼처럼 쓰기 편함. 코드만 재사용하고 싶으면 상속과 위임을 쓰는데 여기서는 위임을 쓰는게 낫다
    
    우리는 add,remove, …이 필요한데 벡터 안에 다른 메소드가 엄청 많이 있는데 상속받으면 그것들 다 받게 됨. Company class에서 employee애 매니저 넣어놓으면 필요없는데도 가지게 됨, 이 예제에서도 상속을 하니까 필요한 것만 쓰고 싶은데 다른 것도 상속받게 됨 : 결합도가 생김
    

→ 위임 사용, 합성관계로 vector와 연결

설계에서도 의미가 안맞음. 필요한 메소드만 위임시키자면 필요한 메소드만 가질 수 있다.

- 메인도 기능이 많아서 쪼갬

*상속을 위임으로 바꾸기 리팩토링, main 메소드에서 메소드 추출하기 리팩토링*

![Untitled](13-1%20Coding%20refactoring%20078cdc36988644ecb237f09f13782c07/Untitled%202.png)

사실은 객체지향에 가장 좋은 것이 상속을 쓰는 것임. 상속을 안쓰니까 type, if-else가 필요하고 유지보수가 안되기에 상속을 넣고 다형성을 적용하면 아주 좋지만 잘못쓰면 안되므로 위임을 쓰는 경우가 더 많음

# 검색할 수 있는 스택 예제

## 버전 1

- searchablestack 클래스의 모든 메소드들은 stack 객체에 있는 동일한 기능의 메소드를 호출만 한다.
    
     searchable-stack is a stack이므로 위임이 아니라 상속을 하는 게 낫다
    

→ 위임에서 상속으로 수정한다

*클래스의 모든 메소드가 다른 클래스에 위해 단순 위임 호출을 당할 경우에는 위임을 상속으로 바꾸기 리팩토링(과잉 중ㅇ개 메소드)*

# 짝,홀값만 들어가는 스택 예제

- stack- stackArray는 스택의 구현방식과 관련된 클래스
- stackArray-evenNumberStackArray, OddNumberStackArray는 스택의 기능과 관련된 클래스

→ 상속 계층에 구현방식과 고유 기능이 모두 포함되어있으므로 두가지를 확장하려면 추가해야할 클래스 수가 많아진다

Stack array는 구현의 관점, even/odd는 기능의 관점

→ 상속의 흐름 하나 안에 구현과 개념/기능의 관점을 결합시켜놔서 구현이 바뀌면 기능을 재사용하지 못하고 다시 구현을 해야 한다

*한 클래스의 상속 계층도가 두가지 이상의 역할을 할 때 상속 계층도 찢어 분리하기 (평행 상속 계층)*

: 벡터나 배열로 구현하는 방식은 전략, strategy 인 것 : 즉 상속이 아니라 위임하여 stackImpl 인터페이스를 상속받아 구체적인 클래스를 만들어줘야 한다

: even, odd는 기능적인 상속이므로 stack에 위임한다. 

Stack imple에서 구현방법이 바뀌더라도 evennumberstack은 바뀌지 않음. 그냥 stackimpl만 가지면 됨

⇒ Stratey pattern 모양

![Untitled](13-1%20Coding%20refactoring%20078cdc36988644ecb237f09f13782c07/Untitled%203.png)

# 애완 동물 로봇 예제

- 상태가 바뀌고 또 다른 상태가 추가된다면 talk함수가 계속 바뀌어야 한다 : 유지보수 불가

→ Talk는 오버라이딩하도록 하고 robot이라는 상위 클래스를 만들고 그 밑에 행복한 로봇, 슬픈 로봇 등등으로 만들어서 오버라이딩하자!, 다형성 적용

i) robot에 기분에 따라 angry robot 이런 형태로 상속받는 형태로 한다면 상태가 자주 바뀌기 때문에 부적절

동물에는 동물원동물과 야생동물을 상속으로 하면 안된다. Is a 관계에서 무너짐

상태이므로 항상 행복한게 아니기 떄문 항상 행복한 로봇이었으면 좋겠다면 상속이고 아니라면 위임으로 해야한다. 전략이 자꾸 바뀔 떄에도 위임으로 해결! 똑같은 방법

ii) 상태가 바뀌니까 상속이 아닌 위임을 사용하여 robot은 state라는 추상 클래스를 가지고 있고 happy, angry,cold는 state를 상속받아 talk를 오버라이딩한다.

*타입 코드에 따라서 행위가 변하는 클래스가 있을 때 그 타입 정보가 객체 생성 이후에도 계속 변할 경우 타입 코드를 state/strategy 패턴을으로 바꾸기* 

- strategy pattern과 모양이 동일

패턴 입장에서는 설계 시 결정하고 리팩토링은 코딩 단계에서 실행

어떤 식으로 고쳐야 하는지를 알면 된다 이름은 다 외울 필요가 없음